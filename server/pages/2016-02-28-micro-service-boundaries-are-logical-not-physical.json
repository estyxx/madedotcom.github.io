{"pageProps":{"source":{"compiledSource":"var p=Object.defineProperty,d=Object.defineProperties;var u=Object.getOwnPropertyDescriptors;var s=Object.getOwnPropertySymbols;var n=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable;var c=(e,t,a)=>t in e?p(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a,o=(e,t)=>{for(var a in t||(t={}))n.call(t,a)&&c(e,a,t[a]);if(s)for(var a of s(t))r.call(t,a)&&c(e,a,t[a]);return e},h=(e,t)=>d(e,u(t));var l=(e,t)=>{var a={};for(var i in e)n.call(e,i)&&t.indexOf(i)<0&&(a[i]=e[i]);if(e!=null&&s)for(var i of s(e))t.indexOf(i)<0&&r.call(e,i)&&(a[i]=e[i]);return a};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(a){var i=a,{components:e}=i,t=l(i,[\"components\"]);return mdx(MDXLayout,h(o(o({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,`My problem with the Microservices movement is that people are applying the lessons of\nmicro-services without having first learned the lessons of service-oriented\narchitecture. This leads to confusion and accidental complexity.`),mdx(\"p\",null,mdx(\"a\",o({parentName:\"p\"},{href:\"https://www.reddit.com/r/devops/comments/47c2jv/suggestion_regarding_microservice_architecture/\"}),\"A redditor asks\"),\":\"),mdx(\"blockquote\",null,mdx(\"p\",{parentName:\"blockquote\"},\"two micro service depend\",\"[ing]\",` on the same data storage ... is a \"No No\" as it can\nintroduce lots of other complexity. But what happens if one of the micro-service is\nonly read only?`)),mdx(\"blockquote\",null,mdx(\"p\",{parentName:\"blockquote\"},`So here is the situation, one micro service will be an internal tool which is doing\nsome heavy lifting and then persisting the data in the data base. And another\nmicro-service will be a REST interface which will just read the data. Is it fine if\nsome one use same database for both of the service?`)),mdx(\"p\",null,`Pro-tip: if you answered \"No\", you're doing it wrong. The kicker: If you answered \"yes\",\nyou're also wrong.`),mdx(\"p\",null,`To understand why, we first need to go back to basics and ask a very simple question:\nWhat is a service? Mulesoft\n`,mdx(\"a\",o({parentName:\"p\"},{href:\"https://www.mulesoft.com/resources/esb/services-in-soa\"}),\"pithily summarise\"),\":\"),mdx(\"blockquote\",null,mdx(\"p\",{parentName:\"blockquote\"},`A service is a self-contained unit of software that performs a specific task...\nBecause the interface of a service is separate from its implementation, a service\nprovider can execute a request without the service consumer knowing how it does so.`)),mdx(\"p\",null,`This is true, but it skips over the most important thing about services, which is that\nServices are business concerns, not a technical detail. The first key idea in the\nMulesoft quote is that services are based on contracts. If you send me data A, B, C then\nI will return data X, Y, Z. The second key idea is that implementation is not relevant\nso long as you implement the contract.`),mdx(\"p\",null,`The linked reddit thread is full of well-intended advice. You should NEVER share a\ndatabase with multiple services. Sharing databases is akin to sharing needles; it might\nseem convenient now, but you'll pay for it in due course.`),mdx(\"p\",null,`The question is wrong, however, because it assumes that the \"heavy lifting\" component\nand the \"REST interface\" are different services.`),mdx(\"p\",null,`In adopting microservices, most people have focused on small deployable units (a\nmicroservice should be small enough that you can rewrite it in a sprint!!) rather than\non small contracts (a microservice should be small enough that you can describe it in\none sentence, without using the words 'but' or 'then').`),mdx(\"h2\",null,\"wut?\"),mdx(\"p\",null,`Let's pretend that our redditor is building a system for modelling an industrial\nprocess. He works for a large enterprise who have an energy-intensive process for making\nwidgets. In order to optimise their costs, the company bids for electricity on the open\nmarket. This allows them to make savings when demand is low, but costs them more when\nelectrical demand is high. It takes three units of electricity to make one widget, which\nmeans that the profit margin on any given widget depends on the cost of electricity when\nthat widget was produced.`),mdx(\"p\",null,mdx(\"img\",o({parentName:\"p\"},{src:\"/images/2016/02/microservice-context.png\",alt:\"Widgets to cash\"}))),mdx(\"p\",null,`The CEO of Acme Widgets inc. wants to see realtime information on electricity\nexpenditure.`),mdx(\"p\",null,\"Our plucky redditor therefore sets forth to build the Widget Profit Reporting Service.\"),mdx(\"p\",null,\"What does this service do? What is the contract?\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Given data on the spot price of electricity through the day\"),mdx(\"li\",{parentName:\"ul\"},\"Given data on widget production through the day\"),mdx(\"li\",{parentName:\"ul\"},\"I will give you the total cost of electricity in widget production.\")),mdx(\"p\",null,`This is very clearly a contract that is expressed in business requirements, not\ntechnical requirements: it doesn't matter how many processes you run, so long as your\nCEO sees accurate numbers.`),mdx(\"p\",null,`The above diagram shows one possible implementation. Pricing data is downloaded from an\nRSS feed. In order to meet the soft-realtime requirement, we accept production\ninformation over a Celery/RabbitMQ queue. Then we run a rules engine to determine what\nwe paid and save the result into a Postgres database.`),mdx(\"p\",null,`The CEO can access that data through a web-browser at any time. Because he's only\naccessing the results of the calculation, we can serve data really quickly, and he can\nsend it to all the board members whenever he likes. This is the basic idea behind\n`,mdx(\"a\",o({parentName:\"p\"},{href:\"http://martinfowler.com/bliki/CQRS.html\"}),\"CQRS\"),\".\"),mdx(\"p\",null,`Note that we have three separate deployable applications, though: a celery consumer that\nreads production data, a go app that reads pricing info, and a Flask application that\nserves our data to the CEO. Since all of these applications are fulfilling the same\ncontract, they are part of the `,mdx(\"em\",{parentName:\"p\"},\"same\"),` service, and because they are part of the same\nservice they can talk to the same database.`),mdx(\"p\",null,`If we take away any one of these components, we can no longer fulfil our contract to the\nCEO. As a result, we are content to deploy all three components together whenever the\ndatabase changes.`),mdx(\"p\",null,`If the codebase is small enough, we can still call this a microservice. It is not a\nmonolith, it is not breaking any rules: (Micro)service boundaries are logical (aligned\nwith business requirements) and not physical (aligned with processes or machines).`))}MDXContent.isMDXComponent=!0;\n","scope":{}},"title":"Microservice boundaries are logical not physical","layout":"post","author":"Bob","tags":["architecture"],"redirect_from":"/micro-service-boundaries-are-logical-not-physical/"},"__N_SSG":true}