{"pageProps":{"source":{"compiledSource":"var c=Object.defineProperty,m=Object.defineProperties;var d=Object.getOwnPropertyDescriptors;var n=Object.getOwnPropertySymbols;var i=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable;var l=(e,t,o)=>t in e?c(e,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[t]=o,a=(e,t)=>{for(var o in t||(t={}))i.call(t,o)&&l(e,o,t[o]);if(n)for(var o of n(t))r.call(t,o)&&l(e,o,t[o]);return e},p=(e,t)=>m(e,d(t));var u=(e,t)=>{var o={};for(var s in e)i.call(e,s)&&t.indexOf(s)<0&&(o[s]=e[s]);if(e!=null&&n)for(var s of n(e))t.indexOf(s)<0&&r.call(e,s)&&(o[s]=e[s]);return o};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(o){var s=o,{components:e}=s,t=u(s,[\"components\"]);return mdx(MDXLayout,p(a(a({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,`Hi, I'm Harry, Bob's coauthor for this series on architecture. Now I don't pretend to be\nan architect`,\"*\",`, but I do know a bit about Python. You know the apocryphal tale about\nbikeshedding `,\"[https://en.wikipedia.org/wiki/Law_of_triviality]\",`? Everyone wants to be\nable to express an opinion, even if it's only about the colour of the bikesheds? Well\nthis will be me essentially doing that about Bob's code. Not questioning the\narchitecture. Just the cosmetics. But, readability counts, so here we go!`),mdx(\"p\",null,`\"Stop Writing Classes\" Despite the fact that Bob swears blind that he was a functional\nprogrammer for years, I think Bob does occasionally let the OO-heavy habits of the C#\nworld take over, and he sees classes everywhere, including plenty of places where they\ndon't really help. OK OK, arguably don't help.`),mdx(\"p\",null,\"Like the man said, Stop Writing Classes \",\"[https://www.youtube.com/watch?v=o9pEzgHorH0]\",`,\nor escape from the Kingdom of Nouns!\n`,\"[https://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html]\",`, or\nperhaps simply:`),mdx(\"p\",null,`It is not enough to simply stop writing Java. You must also stop yourself from writing\nJava using Another Language.`),mdx(\"p\",null,`Let's see if we can't replace a few classes with some more Pythonic patterns, and see if\nit makes some of those architectural patterns easier to read, implement and understand.`),mdx(\"p\",null,`Command handlers as functions If a class only has one method other than its constructor,\nit should probably be a function`),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Jack Diederich\")),mdx(\"p\",null,\"or\"),mdx(\"p\",null,`look for classes with names like \"Handler\", \"Maker\", \"Builder\", \"Factory\", and you'll\nprobably find some good candidates for converting to functions`),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Me. but hardly a novel thought.\")),mdx(\"p\",null,`If you're implementing the Command Handler pattern, you're going to need to represent\ncommands and handlers.`),mdx(\"p\",null,`For commands I can't really fault Bob's use of namedtuples, as imported from the typing\nmodule:`),mdx(\"p\",null,`class ReportIssueCommand(NamedTuple): issue_id: UUID reporter_name: str reporter_email:\nstr problem_description: str`),mdx(\"p\",null,`Unless you're actually using mypy, those types aren't adding much value however. The\nalternative would be the more \"classic\" namedtuple syntax:`),mdx(\"p\",null,'ReportIssueCommand = namedtuple(\"ReportIssueCommand\", ',`[\"issue_id\", \"reporter_name\",\n\"reporter_email\", \"problem_description\"]`,\")\"),mdx(\"h1\",null,\"or the shorter syntax if it doesn't make you nervous:\"),mdx(\"p\",null,`ReportIssueCommand = namedtuple(\"ReportIssueCommand\", \"issue_id reporter_name\nreporter_email problem_description\")`),mdx(\"h1\",null,\"come on, have you seen the implementation? nameduples are magic anyway. get with it!\"),mdx(\"p\",null,`This wasn't available at the time of writing, but Python 3.7 dataclasses\n`,\"[https://docs.python.org/3/library/dataclasses.html]\",` might be worth a look too. You'd\nprobably want to use frozen=True to replicate the immutabilty of namedtuples...`),mdx(\"p\",null,\"But for handlers, use of a class is definitely more up for debate:\"),mdx(\"p\",null,\"class ReportIssueHandler(Handles\",\"[messages.ReportIssueCommand]\",\"):\"),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{}),`def __init__(self, uowm: UnitOfWorkManager):\n    self.uowm = uowm\n\ndef handle(self, cmd):\n    reporter = IssueReporter(cmd.reporter_name, cmd.reporter_email)\n    issue = Issue(cmd.issue_id, reporter, cmd.problem_description)\n\n    with self.uowm.start() as uow:\n        uow.issues.add(issue)\n        uow.commit()\n`)),mdx(\"p\",null,`Using a class like this does buy you a nice separation of the dependencies to be\ninjected (in the constructor) and the actual command that the handler will be applied\nto.`),mdx(\"p\",null,'But the word \"handler\" definitely feels like a case of nouning a verb. So, consider:'),mdx(\"p\",null,`def report_issue(start_uow, cmd): reporter = IssueReporter(cmd.reporter_name,\ncmd.reporter_email) issue = Issue(cmd.issue_id, reporter, cmd.problem_description) with\nstart_uow() as uow: uow.issues.add(issue) uow.commit()`),mdx(\"p\",null,`tying commands to handlers You need some way of connecting commands with their handlers.\nThe most boring way of doing that is in some sort of bootstrap/config code (as in this\nexample) but you might want also want to do so \"inline\" in your handler definition.`),mdx(\"p\",null,\"Bob's way, where the handler class inherits from Handles\",\"[message.ReportIssueCommand]\",`\ndefinitely deserves some points for being easily readable, but you really don't want to\nget into the sausage-factory of the actual implementation, involving, as it does, the\ncontroversial typing module.`),mdx(\"p\",null,\"You might be more comfortable with a decorator instead:\"),mdx(\"p\",null,\"@handles(messages.ReportIssueCommand) def report_issue(start_uow, cmd): ...\"),mdx(\"p\",null,\"But it might get confusing if you also want to use decorators for dependency injection:\"),mdx(\"p\",null,\"@inject('start_uow') def report_issue(start_uow, cmd): ...\"),mdx(\"p\",null,`managing units of work without a UnitOfWorkManager The Unit of Work pattern is one of\nthe more straightforward ones; it's easy to understand why you might want to manage\nblocks of code that need to be executed \"together\" and atomically.`),mdx(\"p\",null,`In a simple project that might just mean wrapping everything in a single database\ntransaction, but you might also want to manage some other types of permanent storage\n(filesystem, cloud storage...).`),mdx(\"p\",null,\"If you're using domain events \",\"[https://io.made.com/why-use-domain-events/]\",`, you might\nalso want to apply the unit-of-work concept to them as well: for a given block of code,\nperhaps a command handler, either raise all the events in the happy case, or raise none\nat all (analogous to a rollback) if an error occurs at any point. This gives you the\noption to replay the command handler later without worrying about duplicate events.`),mdx(\"p\",null,`In that case your unit of work manager needs to grow some logic for tracking a stack of\nevents raised by a block of code, as suggested in the domain events post\n`,\"[https://io.made.com/why-use-domain-events/]\",\".\"),mdx(\"p\",null,`a unit of work should probably be a context manager Either way, Bob nailed it, a Python\ncontext manager is the right pattern here. Here's the outline of his class-based one:`),mdx(\"p\",null,\"class SqlAlchemyUnitOfWork(UnitOfWork):\"),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{}),`def __init__(self, session_factory, bus):\n    ...\n\ndef __enter__(self):\n    self.session = self.session_factory()\n    self.events = []\n    return self\n\ndef __exit__(self):\n    self.session.close()\n    self.publish_events()\n\ndef commit(self):\n    ...\n\ndef publish_events(self, session, ctx):\n    ...\n`)),mdx(\"p\",null,`It's great! but does the rest of the implementation really need to involve three\ndifferent classes?`),mdx(\"p\",null,\"class SqlAlchemy:\"),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{}),`def __init__(self, uri):\n    self.engine = create_engine(uri)\n    self._session_maker = scoped_session(sessionmaker(self.engine),)\n\n@property\ndef unit_of_work_manager(self):\n    return SqlAlchemyUnitOfWorkManager(self._session_maker, self.bus)\n`)),mdx(\"p\",null,\"class SqlAlchemyUnitOfWorkManager(UnitOfWorkManager):\"),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{}),`def __init__(self, session_factory: SessionFactory, bus: MessageBus):\n    self.session_factory = session_factory\n    self.bus = bus\n\ndef start(self):\n    return SqlAlchemyUnitOfWork(self.session_factory, self.bus)\n`)),mdx(\"p\",null,\"Each class does have a purpose of course:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},`SqlAlchemy captures config info about SqlAlchemy and our database engine, it has\nmethods like create_schema that can re-create the database for us if we need.`),mdx(\"li\",{parentName:\"ul\"},`SqlAlchemyUnitOfWorkManager is meant to hold logic about when to create new database\nsessions and when to re-use existing ones, and it ties the message bus to each unit of\nwork.`),mdx(\"li\",{parentName:\"ul\"},`SqlAlchemyUnitOfWork is the actual context manager that holds the logic for commits,\nrollbacks, and publishing events atomically.`)),mdx(\"p\",null,`But can we make things a little simpler? SqlAlchemy (the library) already knows how\nmanage sessions for us. Perhaps we could just have one model for the database, and\nanother for the units of work?`),mdx(\"p\",null,\"from sqlalchemy.orm import sessionmaker\"),mdx(\"p\",null,\"class SqlAlchemy:\"),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{}),`def __init__(self, uri, bus):\n    self.engine = create_engine(uri)\n    self.session_factory = sessionmaker(self.engine)\n    self.bus = bus\n\ndef start_unit_of_work(self):\n    return SqlAlchemyUnitOfWork(self.session_factory, self.bus)\n`)),mdx(\"p\",null,`could you use an @contextmanager? We're down to just two classes. Next you might ask\nwhether you really need a class for your unit of work context manager. If your client\ncode doesn't need to call a commit method explicitly, then you might be able to get away\nwith a single method, using contextlib.contextmanager and the yield keyword:`),mdx(\"p\",null,\"from contextlib import contextmanager\"),mdx(\"p\",null,\"class SqlAlchemy: ...\"),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{}),`@contextmanager\ndef start_unit_of_work(self):\n    session = self.session_factory()\n    events = []\n    try:\n        yield session\n        self.publish_events(session)\n        session.commit()\n    except Exception as e:\n        session.rollback()\n        session.close()\n\ndef publish_events(self, session):\n    flushed_objects = [e for e in session.new] + [e for e in session.dirty]\n    for o in flushed_objects:\n        for e in o.events\n            self.bus.handle(e)\n`)),mdx(\"p\",null,`the singleton pattern in Python We still have one final class, SqlAlchemy, which exists\nto`),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"know how to talk to our database\"),mdx(\"li\",{parentName:\"ul\"},\"give us units of work\"),mdx(\"li\",{parentName:\"ul\"},\"tie the message bus to it.\")),mdx(\"p\",null,`It's essentially a singleton, in that our application is only ever meant to have one\ninstance of it. There are lots of ways to implement the singleton pattern in Python\n`,\"[https://stackoverflow.com/questions/31875/is-there-a-simple-elegant-way-to-define-singletons]\"),mdx(\"p\",null,`In this case our implementation is the ultra-simple \"by convention there is only one\ninstance of this class\", which is has a lot going for it in terms of ways to implement\nthe singleton pattern, compared to all the complicated code-based solutions linked\nabove. If you do want a code-based solution, or if you want to continue experimenting\nwith non-class-based solutions to these problems, why not use the \"just use a module\"\nsolution - modules are essentially already singletons, in Python:`),mdx(\"h1\",null,\"adapters/sqlalchemy.py\"),mdx(\"p\",null,\"BUS = None SESSION_MAKER = None\"),mdx(\"h1\",null,\"to be called in our bootstrap/config script\"),mdx(\"p\",null,`def setup(uri, bus): global BUS, SESSION_MAKER BUS = bus SESSION_MAKER =\nsessionmaker(create_engine(uri))`),mdx(\"p\",null,`@contextmanager def start_unit_of_work(): session = SESSION_MAKER() events = [] try:\nyield session `,\"_\",`publish_events(session) session.commit() except Exception as e:\nsession.rollback() session.close()`),mdx(\"p\",null,\"def \",\"_\",\"publish_events(session): flushed_objects = \",\"[e for e in session.new]\",\" + \",`[e for e in\nsession.dirty]`,\" for o in flushed_objects: for e in o.events BUS.handle(e)\"),mdx(\"p\",null,`We may be drifting a little too far into \"removing classes for its own sake\" territory\nhere. But hopefully you now have a few more options to use for inspiration in your own\ncode.`),mdx(\"hr\",null),mdx(\"p\",null,\"*\",\"NARRATORS VOICE: Harry pretends to be an architect all the time\"))}MDXContent.isMDXComponent=!0;\n","scope":{}},"date":"2018-10-05","layout":"post","title":"Removing classes from Ports and Adapters","author":"Harry","categories":["ports & adapters"],"tags":["python","architecture"]},"__N_SSG":true}