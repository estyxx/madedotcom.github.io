{"pageProps":{"source":{"compiledSource":"var c=Object.defineProperty,u=Object.defineProperties;var h=Object.getOwnPropertyDescriptors;var a=Object.getOwnPropertySymbols;var n=Object.prototype.hasOwnProperty,i=Object.prototype.propertyIsEnumerable;var m=(e,t,o)=>t in e?c(e,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[t]=o,r=(e,t)=>{for(var o in t||(t={}))n.call(t,o)&&m(e,o,t[o]);if(a)for(var o of a(t))i.call(t,o)&&m(e,o,t[o]);return e},l=(e,t)=>u(e,h(t));var p=(e,t)=>{var o={};for(var s in e)n.call(e,s)&&t.indexOf(s)<0&&(o[s]=e[s]);if(e!=null&&a)for(var s of a(e))t.indexOf(s)<0&&i.call(e,s)&&(o[s]=e[s]);return o};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(o){var s=o,{components:e}=s,t=p(s,[\"components\"]);return mdx(MDXLayout,l(r(r({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,\"In a previous post \",\"[https://io.made.com/blog/rek-it/]\",` I said I was interested in\nreplacing Logstash with Rsyslog in our ELK stack. I've been working on one of the\noutstanding items from that project - the ability to send metrics to Riemann. The\nMade.com `,\"[https://github.com/madedotcom/rsyslog/tree/omriemann]\",` fork of Rsyslog now has\nan alpha-quality version of the Riemann output module. Although there's still some\nmissing functionality for more advanced scenarios, we can already do interesting things\nwith the module as it stands.`),mdx(\"p\",null,`For our first example, let's imagine that we want to trigger an alert if our log volume\nchanges drastically. For example, we may stop receiving events if there is a networking\nproblem; or we might start writing many more events than usual if there is an error in\none of our systems.`),mdx(\"p\",null,\"We can achieve this with the rsyslog impstats module and the riemann output module.\"),mdx(\"p\",null,\"Firstly we need to configure rsyslog to record its statistics.\"),mdx(\"h1\",null,\"We'll need to load the riemann module before we can use it\"),mdx(\"p\",null,'module(load=\"omriemann\")'),mdx(\"p\",null,`#impstats generates internal metrics for us on an interval module(load=\"impstats\" # use\na json format format=\"cee\" # send metrics every 10 secs interval=\"10\" # send a\nrate-of-change event, like a collectd counter. resetCounters=\"on\" # pass these messages\nto the \"stats\" ruleset for processing ruleset=\"stats\") module(load=\"mmjsonparse\")`),mdx(\"p\",null,`ruleset(name=\"stats\") { # parse the json message action(name=\"parse-stats\"\ntype=\"mmjsonparse\")`),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{}),`# pass it to riemann\naction(name=\"riemann-output\" type=\"omriemann\"\n       # look for metrics in the root json object\n       subtree=\"!\"\n\n       # and forward them to MYSERVER\n       server=\"MYSERVER\")\n`)),mdx(\"p\",null,\"}\"),mdx(\"p\",null,\"Secondly, we need to add some config to Riemann.\"),mdx(\"p\",null,\"; Listen for TCP connections (let \",'[host \"0.0.0.0\"]',\" (tcp-server {:host host}))\"),mdx(\"p\",null,`(streams ; ignore riemann's internal metrics (where (not (tagged \"riemann\")) ; write all\nincoming events to stdout prn ))`),mdx(\"p\",null,\"After we start both processes up, we should start seeing logs like this from Riemann.\"),mdx(\"p\",null,'{:service \"parse-stats/processed\", :state \"ok\", :metric 5 }'),mdx(\"p\",null,'{:service \"riemann-output/processed\", :state \"ok\", :metric 5}'),mdx(\"p\",null,`So how can we use this to trigger alerts? Firstly let's add some more config to rsyslog.\nWe're going to listen to a TCP socket and we want to monitor the number of messages we\nreceive.`),mdx(\"p\",null,`module (load=\"imuxsock\") input (type=\"imuxsock\" ruleset=\"sock\"\nSocket=\"/run/rsyslog/imux.sock\")`),mdx(\"p\",null,'ruleset(name=\"sock\") { action(name=\"write-to-file\" type=\"omfile\" file=\"/var/log/tcp\") }'),mdx(\"p\",null,`Now we can write some logs into rsyslog with the logger utility, and we should start\nseeing new metrics in Riemann.`),mdx(\"p\",null,'{:service \"imuxsock/submitted\", :state \"ok\" :metric 2}'),mdx(\"p\",null,'{:service \"write-to-file/processed\", :state \"ok\", :metric 2}'),mdx(\"p\",null,`To raise an alert based on these metrics we're going to set some arbitrary thresholds,\nbut we could do more sophisticated analysis to do anomaly detection. We'll set up the\nfollowing rules:`),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"If we receive fewer than 10 messages in 5 minutes, we should send an email.\"),mdx(\"li\",{parentName:\"ul\"},\"If we receive more than 100 messages in 5 minutes, we should send an email.\"),mdx(\"li\",{parentName:\"ul\"},`Once the log rate settles down to between 10 and 100 messages per 5 mins, we should\nsend an email to say that everything has returned to normal.`)),mdx(\"p\",null,\"We'll update our riemann config to look like this\"),mdx(\"p\",null,`(def email (mailer {:host \"smtp.mydomain.com\" :user \"foo\" :pass \"bar\" :from\n\"`,mdx(\"a\",r({parentName:\"p\"},{href:\"mailto:riemann@mydomain.com\"}),\"riemann@mydomain.com\"),'\"}))'),mdx(\"p\",null,\"(streams\"),mdx(\"pre\",null,mdx(\"code\",r({parentName:\"pre\"},{}),`(where (service \"imuxsock/submitted\")\n  ; set up a moving time window over the last 5 mins\n  (moving-time-window 300; 300 secs == 5 mins\n    ; we want the total number of messages received over the period\n    (smap folds/sum\n      ; this helper maps threshold values to states\n      (pipe p (splitp > metric\n          10 (with :state \"error\" p) ; < 10 is an error\n          100 (with :state \"ok\" p)   ; < 100 is ok\n          Integer/MAX_VALUE (with :state \"error\" p)); anything 100 to infinity is an error\n\n         ; If the state changes (from, ok to error or the other direction)\n         (changed-state\n         ;   (email \\u201Csysops@mydomain.com\\u201D)\n            prn\n\n          ))))))\n`)),mdx(\"p\",null,`After we update our config, and wait a few minutes, we should see an error logged by\nriemann.`),mdx(\"p\",null,'{:service \"imuxsock/submitted\", :state \"error\", :metric 0}'),mdx(\"p\",null,`We can test the resolution by running logger again, but this time using watch to run it\nevery 5 seconds: watch -n5 logger \"hello world\". After another few minutes, riemann\nshould log the ok event.`),mdx(\"p\",null,'{:service \"imuxsock/submitted\", :state \"ok\", :metric 60}'),mdx(\"p\",null,`Lastly, if we change our watch statement so that we call logger every second, we can\ntrigger the other threshold.`),mdx(\"p\",null,'{:service \"imuxsock/submitted\", :state \"error\", :metric 188}'),mdx(\"p\",null,`We've only scratched the surface of Riemann's capabilities here, but we can already see\nhow Rsyslog and Riemann can work together to give actionable alerts from our log data.`))}MDXContent.isMDXComponent=!0;\n","scope":{}},"date":"2016-12-30","title":"Monitoring with Riemann and rsyslog part 1","layout":"post","author":"Bob","tags":["riemann","monitoring","elk"]},"__N_SSG":true}