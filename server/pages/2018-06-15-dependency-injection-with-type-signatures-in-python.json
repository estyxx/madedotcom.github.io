{"pageProps":{"source":{"compiledSource":"var p=Object.defineProperty,h=Object.defineProperties;var u=Object.getOwnPropertyDescriptors;var i=Object.getOwnPropertySymbols;var r=Object.prototype.hasOwnProperty,o=Object.prototype.propertyIsEnumerable;var d=(e,n,t)=>n in e?p(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,s=(e,n)=>{for(var t in n||(n={}))r.call(n,t)&&d(e,t,n[t]);if(i)for(var t of i(n))o.call(n,t)&&d(e,t,n[t]);return e},l=(e,n)=>h(e,u(n));var c=(e,n)=>{var t={};for(var a in e)r.call(e,a)&&n.indexOf(a)<0&&(t[a]=e[a]);if(e!=null&&i)for(var a of i(e))n.indexOf(a)<0&&o.call(e,a)&&(t[a]=e[a]);return t};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(t){var a=t,{components:e}=a,n=c(a,[\"components\"]);return mdx(MDXLayout,l(s(s({},layoutProps),n),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,`Dependency injection is not crazy, not un-pythonic, and not enterprisey. Here's\nWikipedia:`),mdx(\"p\",null,`In software engineering, dependency injection is a technique whereby one object supplies\nthe dependencies of another object. A dependency is an object that can be used (a\nservice). An injection is the passing of a dependency to a dependent object (a client)\nthat would use it. The service is made part of the client's state. The intent behind\ndependency injection is to decouple objects to the extent that no client code has to be\nchanged simply because an object it depends on needs to be changed to a different one.`),mdx(\"p\",null,`In other words, Dependency Injection (DI, for all you jargon-fans out there) is when an\nobject is given its dependencies instead of reaching out to get them by itself. For\nexample, in this series we're building a system for managing IT support issues. Last\ntime we had a requirement to send an email when an issue was assigned to an engineer.\nOur handler is orchestration code that plugs together two collaborators: a View Builder\nthat fetches data, and an Email Sender that knows how to send an email to the mail\nserver.`),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-python\"}),`class IssueAssignedHandler:\n\n    def __init__(self, sender: EmailSender, view: IssueViewBuilder):\n        self.sender = sender\n        self.view = view\n\n    def handle(self, msg):\n        data = self.view.fetch(cmd.issue_id)\n        sender.send_email(emails.IssueAssigned, data)\n`)),mdx(\"p\",null,`This is dependency injection. We're injecting the dependencies (the sender and view) by\nmaking them parameters of the constructor. That's it. Passing our parameters this way\nmakes them more explicit, and so reduces the overall quantity of Unpleasant Surprise\nhiding in the system. Because I'm providing all my dependencies from outside of my\nhandler, I can change them easily, or provide fakes. This helps to keep the system\nloosely-coupled and flexible. It also means that I have to think about what the\ndependencies of my system ought to be, and that helps me to define meaningful\nabstractions.`),mdx(\"p\",null,`Dependency injection is really just a way of performing\n`,mdx(\"a\",s({parentName:\"p\"},{href:\"https://www.pydanny.com/python-partials-are-fun.html\"}),\"partial application\"),` on a method\ncall. Earlier in this series, I said that I often create handlers by abusing the\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"__call__\"),\" magic method.\"),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-python\"}),`class IssueAssignedHandler:\n\n    def __init__(self, sender, view):\n        self.view = view\n        self.sender = sender\n\n    def __call__(self, cmd):\n        data = self.view.fetch(cmd.issue_id)\n        sender.send_email(emails.IssueAssigned, data)\n\nhandler = IssueAssignedHandler(sender, view) handler(cmd)\n`)),mdx(\"p\",null,`Calling the constructor of IssueAssignedHandler returns a callable. Compare that with\nthe following examples of partial application:`),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{}),`def explicit_closure_handler(self, sender, view):\n\n    def h(self, cmd):\n        data = view.fetch(cmd.issue_id)\n        ...\n    return h\n\n\nhandler_a = explicit_closure_handler(sender, view) handler_a(cmd)\n\nfrom functools import partial def send_assignment_email(sender, view, cmd): data =\nview.fetch(cmd.issue_id) ...\n\nhandler_b = partial(send_assignment_email, sender, view) handler_b(cmd)\n`)),mdx(\"p\",null,`The callables handler, handler_a, and handler_b all take a single argument (the command)\nand run the same code on it, so we can see that they are functionally equivalent.\nDependency injection is just a way of parametising the behaviour of our applications by\npartially applying function arguments.`),mdx(\"p\",null,`The advantage of building a system this way is that it's very easy to test, configure,\nand extend the behaviour of our application through composition. Dynamic languages offer\nmany ways to fake the behaviour of a component, but my preference is to write explicit\nfakes and stubs, and to pass them as constructor arguments. This forces me to think\nabout my system in terms of composable parts, and to identify the roles that they play.\nInstead of directly calling the database from my handler, I'm providing an\nIssueViewBuilder. Instead of writing a load of SMTP code in my handler, I'm providing an\ninstance of EmailSender.`),mdx(\"p\",null,`This, for me at least, is the simplest, most obvious, and least magical way of dealing\nwith dependencies, especially across architectural boundaries. Performing dependency\ninjection - whether by constructor injection or partial application, or some magic\nproperty-filling decorator - is mandatory if you want to do ports and adapters. It's the\n\"one weird trick\" that allows high-level code (business logic) to remain completely\nisolated from low level code (database transactions, file operations, email sending\netc.)`),mdx(\"p\",null,`You don't need to use a framework for DI Dependency injection gets a bad rap in the\nPython community for reasons that escape me. I think it's because people assume that you\nneed to use a framework to perform the injection, and they're terrified of ending up in\nan xml-driven hellscape like\n`,mdx(\"a\",s({parentName:\"p\"},{href:\"https://memorynotfound.com/spring-mvc-xml-configuration-example/\"}),\"Spring\"),`. This isn't\ntrue, you can still perform dependency injection with no frameworks at all. For example,\nin the code sample for the previous part in this series, I extracted all my wiring into\na single module with boring code that looks like this:`),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-python\"}),`db = SqlAlchemy('sqlite:///issues.db') db.configure_mappings() db.create_schema()\n\nbus = MessageBus() db.associate_message_bus(bus)\n\nissue_view_builder = IssueViewBuilder(db) issue_list_builder = IssueListBuilder(db)\n\nreport_issue = ReportIssueHandler(db.unit_of_work_manager) assign_issue =\nAssignIssueHandler(db.unit_of_work_manager) triage_issue =\nTriageIssueHandler(db.unit_of_work_manager) issue_assigned =\nIssueAssignedHandler(issue_view_builder, LoggingEmailSender())\nbus.subscribe_to(msg.ReportIssueCommand, report_issue)\nbus.subscribe_to(msg.TriageIssueCommand, triage_issue)\nbus.subscribe_to(msg.IssueAssignedToEngineer, issue_assigned)\nbus.subscribe_to(msg.AssignIssueCommand, assign_issue)\n`)),mdx(\"p\",null,`This code is just a straight-line script that configures the database, creates all of\nour message handlers, and then registers them with the message bus. This component is\nwhat an architect would call a\n`,mdx(\"a\",s({parentName:\"p\"},{href:\"http://blog.ploeh.dk/2011/07/28/CompositionRoot/\"}),\"Composition Root\"),`. On my current\nteams, we tend to call this a bootstrap script. As systems grow, though, and\nrequirements become more complex, this bootstrapper script can become more repetitive\nand error-prone. Dependency injection frameworks exist to remove some of the\nboiler-plate around registering and wiring up dependencies. In recent years the\n.Net-hipster crowd have started to move away from complex dependency injection\ncontainers in favour of simpler composition roots. This is variously known as poor man's\nDI, pure DI, or artisinal organic acorn-fed DI.`),mdx(\"p\",null,`Usually, on our Python projects at Made.com, we use the\n`,mdx(\"a\",s({parentName:\"p\"},{href:\"https://pypi.python.org/pypi/Inject/3.1.1\"}),\"inject\"),` library. This is a simple tool that\nperforms the partial application trick I demonstrated above. Inject is my favourite of\nthe Python DI libraries because it's so simple to use, but I have a dislike for its use\nof decorators to declare dependencies.`),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-python\"}),`import inject\n\n# client code\n\nclass IssueAssignedHandler:\n\n    @inject(sender='email_sender', view='issue_view_builder')\n    def __init__(self, sender, view):\n        pass\n\n    def handle(self, cmd):\n        pass\n\n\n# configuration\n\ndef configure_binder(binder): db = SqlAlchemy('sqlite://')\n    binder.bind('email_sender', SmtpEmailSender(host=..., port=..., username=...))\n    binder.bind('issue_view_builder', IssueViewBuilder)\n\n    inject.configure(configure_binder)\n\n    handler = IssueAssignedHandler()\n`)),mdx(\"p\",null,`The configure_binder function takes the place of my bootstrap script in wiring up and\nconfiguring my dependencies. When I call IssueAssignedHandler the inject library knows\nthat it should replace the sender param with the configured SmtpEmailSender, and that it\nshould replace the view param with an IssueViewBuilder. The decorator serves to\nassociate the service (\"email_sender\") with the parameter (\"sender\"), but it always\nfeels inappropriate to have this kind of declaration outside of my composition root.`),mdx(\"p\",null,\"I've been working on a \",mdx(\"a\",s({parentName:\"p\"},{href:\"https://github.com/bobthemighty/punq\"}),\"prototype DI framework\"),`\nthat avoids this problem by using\n`,mdx(\"a\",s({parentName:\"p\"},{href:\"https://docs.python.org/3/library/typing.html\"}),\"Python 3.6's optional type hinting\"),`, and\nI'd like to show you some use cases.`),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-python\"}),`import punq\n\n# client code\n\nclass IssueAssignedHandler: # We use type hints to declare what dependencies we need def\n    def __init__(self, sender: EmailSender, view: IssueViewBuilder):\n        self.sender = sender\n    self.view = view\n\n    def handle(self, cmd):\n        pass\n\n# configuration\n\ncontainer = punq.container()\n\n# We can register a singleton instance of a dependency\n\ncontainer.register(EmailSender, SmtpEmailSender(host=..., port=..))\n\n# Or a class that implements a particular service\n\ncontainer.register(UnitOfWorkManager, SqlAlchemyUnitOfWorkManager)\n\n# Or register the service itself\n\ncontainer.register(IssueViewBuilder)\n\nhandler = container.resolve(IssueAssignedHandler)\n`)),mdx(\"p\",null,`So far, so underwhelming. Simple registrations don't really save us anything over the\nbootstrap script from earlier. Using a container for this kind of work really only cuts\ndown on duplication - when I've registered UnitOfWorkManager once, I never have to refer\nto it again, whereas in the bootstrap I had to explicitly pass it to every handler. It's\nnice not having to decorate my class with dependency injection specific noise though,\ninstead I can just declare what my dependencies are. As an added bonus, I can run mypy\nover my code and it will tell me if I've made any stupid type errors.`),mdx(\"p\",null,`There are more useful things we can do with a dependency injection container, though.\nFor example, maybe we're writing a program that needs to run a bunch of processing rules\nover some text. We decide to treat each processing rule as a function and use our\ncontainer to fetch them all at runtime.`),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-python\"}),`# string_processing_rule is just an alias\n\n# for a function of str -> str\n\nstring_processing_rule = Callable[[str], str]\n\nclass StringProcessor:\n\n    def __init__(self, rules: List[string_processing_rule]):\n        self.rules = rules\n\n    def process(self, input):\n        for rules in self.rules:\n            input = rule(input)\n        return input\n\ndef upper_case(input: str) -> str:\n    return str.upper()\n\ndef reverse(input: str) -> str:\n    return reversed(str)\n\ncontainer = punq.container() container.register(string_processing_rule, upper_case)\ncontainer.register(string_processing_rule, reverse)\n\nprocessor = container.resolve(StringProcessor)\n\n# prints (\"DLORW OLLEH\")\n\nprint(processor.process(\"hello world\"))\n`)),mdx(\"p\",null,`One of the advantages of using types over using other keys is that they're composable. I\ncan ask for a List`,\"[T]\",` and get all registered instances of some T. This is handy when\nyou're writing code that processes the same message with a bunch on different steps,\nincluding rules engines and message buses. Having generics in our type system can make\nit easier to manage all of our dependencies in other ways, too. For example, I can use\ngenerics to automatically wire up all my message handlers.`),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-python\"}),`class IssueAssignedHandler (Handles[IssueAssignedEvent]): pass\n`)),mdx(\"p\",null,`Here we're stating that our IssueAssignedHandler is an subtype of the Handles class, and\nit has a type parameter for the handled event. Given a module full of these, I can\nenumerate the module's types and perform automatic registration.`),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-python\"}),`def register_all(module):\n    \"\"\" Read through all the types in a module and register them\n    if they are handlers\"\"\"\n\n    for _, type in inspect.getmembers(module, predicate=inspect.isclass):\n        register(type)\n\ndef register(type):\n    \"\"\" If this type is a handler type then register it in the container\"\"\"\n    handler_service_type = get_message_type(type)\n    if handler_service_type is None:\n        return container.register(handler_service_type, type)\n\ndef get_message_type(type):\n    \"\"\" If this type subclasses the Handles[TMsg] class, return\n    the parameterised type. eg. for our IssueAssignedHandler, this would return\n    Handles[IssueAssignedEvent] \"\"\"\n\n    try:\n        for base in type.__orig_bases__:\n            if base.__origin__ == services.Handles:\n              return base\n    except Exception:\n        pass\n\ndef resolve_handler(event_type):\n    container.resolve(Handles[event_type])\n\nclass MessageHandler:\n    def handle(self, next:MessageHandler):\n        pass\n\nclass LoggingHandler:\n\n    def __init__(self, next: MessageHandler):\n        self.next = next\n\n    def handle(self, msg):\n        logging.info(\"Handling message %s\", msg)\n        next.handle(msg)\n\nclass DefaultHandler:\n\n    def __init__(self, next: MessageHandler, container:punq.Container):\n        self.next = next\n        self.container = container\n\n    def handle(self, msg):\n        handler = container.resolve(Handles[type(msg)])\n        handler.handle(msg)\n\ncontainer.register(MessageHandler, DefaultHandler)\ncontainer.register(MessageHandler, LoggingHandler)\n\ncontainer.register(Handles[IssueAssigned], IssueAssignedHandler)\n\nbus = container.resolve(MessageBus)\n\n# calls logging handler, and then DefaultHandler\n\nbus.handle(msg)\n`)),mdx(\"p\",null,`Because each MessageHandler depends on another MessageHandler, punq treats them as a\nchain, and injects them into each other like a stack of Russian dolls. I can hear the\nPython faithful baying for blood at this point. Why would anyone want to do this when\nPython already has such great support for decorators? The only reason to ever do this in\nPython is if you want to inject dependencies into your decorators. In the following code\nwe add two new message handlers, a metrics handler that records the runtime of our\nhandler pipeline so we can monitor our application, and a de-duplicating handler that\nprevents us from handling the same message twice. Both of these require complex\ndependencies of their own, so we can delegate their creation to the container.`),mdx(\"pre\",null,mdx(\"code\",s({parentName:\"pre\"},{className:\"language-python\"}),`class MetricsGatheringHandler(MessageHandler):\n\n    def __init__(self, metrics: MetricsCollector, next: MessageHandler):\n        self.metrics = metrics\n\n    def handle(self, msg):\n        # Record the time taken when we process a message\n        with self.metrics.time('command/execution-time'):\n            self.next.handle(msg)\n\nclass DedeuplicatingHandler (MessageHandler):\n\n    def __init__(self, filter:MessageFilter, next:MessageHandler):\n        self.next = next\n        self.filter = filter\n\n    def handle(self, msg):\n        if self.filter.is_duplicate(msg):\n            logging.warn(\"msg %s is a duplicate. Skipping\", msg)\n            return\n\n        try:\n            self.next.handle(msg)\n        finally:\n            self.filter.record(msg.id)\n\nontainer.register(MetricsCollector, StatsdMetricsCollector)\ncontainer.register(MessageFilter, InMemoryMessageFilter)\ncontainer.register(MessageHandler, MetricsGatheringHandler)\ncontainer.register(MessageHandler, DedeuplicatingHandler)\n`)),mdx(\"h1\",null,\"Deduplicates, records metrics, writes a log file, and invokes our Command Handler\"),mdx(\"p\",null,\"container.resolve(MessageHandler).handle(msg)\"),mdx(\"p\",null,`This is what I meant in the last part when I said that a message bus is a great place to\nput cross-cutting concerns. Validation, exception handling, db session management, and\nbasic logging are all great candidates for decorators on our message bus, and DI makes\nit easy for us to write and test those components separately. Next time I want to get\nback to the issues codebase and talk about how ports and adapters helps provide\ntechnology agnosticism.`))}MDXContent.isMDXComponent=!0;\n","scope":{}},"date":"2018-06-15","title":"Dependency Injection with type signatures in python","layout":"post","author":"Bob","categories":["ports & adapters"],"tags":["python","architecture"]},"__N_SSG":true}