{"pageProps":{"source":{"compiledSource":"var c=Object.defineProperty,m=Object.defineProperties;var h=Object.getOwnPropertyDescriptors;var n=Object.getOwnPropertySymbols;var s=Object.prototype.hasOwnProperty,i=Object.prototype.propertyIsEnumerable;var p=(e,t,o)=>t in e?c(e,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[t]=o,a=(e,t)=>{for(var o in t||(t={}))s.call(t,o)&&p(e,o,t[o]);if(n)for(var o of n(t))i.call(t,o)&&p(e,o,t[o]);return e},l=(e,t)=>m(e,h(t));var u=(e,t)=>{var o={};for(var r in e)s.call(e,r)&&t.indexOf(r)<0&&(o[r]=e[r]);if(e!=null&&n)for(var r of n(e))t.indexOf(r)<0&&i.call(e,r)&&(o[r]=e[r]);return o};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(o){var r=o,{components:e}=r,t=u(r,[\"components\"]);return mdx(MDXLayout,l(a(a({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,`It's been a little longer than I expected, but I'm finally back and working on Rsyslog.\nLast time `,\"[http://io.made.com/blog/monitoring-with-riemann-and-rsyslog-part-1/]\",`, we\nlooked at how impstats could be used to generate internal metrics from Rsyslog, and how\nto alert on those metrics in Riemann.`),mdx(\"p\",null,`This time I want to look at how the Dynstats module\n`,\"[http://www.rsyslog.com/doc/master/configuration/dyn_stats.html]\",` in Riemann can be used\nto do more interesting monitoring of our applications.`),mdx(\"p\",null,`The Dynstats module provides a simple interface for counting events in Rsyslog. Any time\nwe see a particular pattern in our logs, or we receive a log file from a particular\napplication, we can increment a counter.`),mdx(\"p\",null,`For our first use-case, we're going to use this to record error counts for each of our\napplications. This is one of the simplest and most important metrics that you can\ncapture since most production issues will cause an increase in error rate. When the\n\"Error Rate > Threshold\" alarm goes off, it could be a bad deploy, a misconfigured app,\na bug in your code, or a failing disk on the database server. While you definitely want\nmore granular metrics to help you diagnose problems, this broad approach is fantastic as\nan early warning system.`),mdx(\"p\",null,`For this post, I've put together a docker-compose playground\n`,\"[https://github.com/bobthemighty/rek-stack-demos]\",`. If you want to play along, you'll\nneed a recent version of Docker Compose. Check out the code, and take a look in the\ndynstats/dummy directory.`),mdx(\"p\",null,`To demonstrate a error counter, I've written a quick and dirty Go program that randomly\noutputs either a notice or error level log at regular intervals. We can set the\ninterval, log tag, and error percentage on the command line.`),mdx(\"p\",null,\"docker-compose run dummy -interval 100 -tag foo\"),mdx(\"p\",null,`We can use the dynstats functionality in Rsyslog to count the number of errors that\nhappen in a 10-second window, and send the counter over to Riemann.`),mdx(\"h1\",null,\"We use the dyn_stats function to create a new metrics bucket.\"),mdx(\"h1\",null,\"Each bucket can contain many counters.\"),mdx(\"p\",null,'dyn_stats(name=\"error_rate\")'),mdx(\"h1\",null,'When we receive an \"error\" log, we will add 1 to the counter'),mdx(\"h1\",null,\"for the application that raised the error. We use the $programname\"),mdx(\"h1\",null,\"parsed from the Syslog tag to identify the application.\"),mdx(\"p\",null,`if\n($syslogseverity-text == \"error\") then { set $foo = dyn_inc(\"error_rate\",\n$programname);\n}`),mdx(\"h1\",null,\"Lastly, here's our stats processing.\"),mdx(\"h1\",null,\"Parse the JSON that impstats forwards to us and spit it straight out to Riemann\"),mdx(\"p\",null,`ruleset(name=\"stats\") { action(name=\"parse-stats\" type=\"mmjsonparse\")\naction(name=\"send-to-riemann\" type=\"omriemann\" subtree=\"!\" server=\"riemann\") }`),mdx(\"p\",null,`We can bring this up by running docker-compose up from the root of the demo project.\nAfter everything has started up, you should start to see regular metrics counting the\nnumber of errors.`),mdx(\"p\",null,\"riemann_1 | INFO \",\"[2017-05-29 09:26:11,285]\",` defaultEventExecutorGroup-2-1 -\nriemann.config - error rate/dummy-logger = 9 riemann_1 | INFO `,\"[2017-05-29 09:26:21,259]\",`\ndefaultEventExecutorGroup-2-1 - riemann.config - error rate/dummy-logger = 16`),mdx(\"p\",null,`We can extend our Riemann config so that we raise an error if a metric is above an\nabsolute threshold. Open the file riemann/riemann.config . We're going to edit the\nconfig to add a new rule: when the error_rate is > 10, log an error. In practice, we\nwould want to send an alert to an operator via email, Slack, or PagerDuty. Add the\nfollowing line below the prn on line 13:`),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{}),`    (where (< 10 metric) #(error \"Alert! error rate is now \" (:metric %)))\n`)),mdx(\"p\",null,`Restart everything with docker-compose restart and wait a few seconds. You should start\nto see output like this:`),mdx(\"p\",null,`riemann_1 | INFO defaultEventExecutorGroup-2-1 - riemann.config - error\nrate/dummy-logger = 9 riemann_1 | INFO defaultEventExecutorGroup-2-1 - riemann.config -\nerror rate/dummy-logger = 15 riemann_1 | ERROR - Alert! error rate is now 15`),mdx(\"p\",null,`For our second use case, we're going to look at how dynstats and riemann can give us\nsome monitoring of web applications. One of the strong points of rsyslog is its ability\nto rapidly parse large amounts of log text and pull out meaningful fields. Rsyslog can\nparse logs fast enough that we can use it for realtime monitoring of applications. Using\nmmnormalize, dynstats, and omriemann we can monitor our web applications in\nnear-realtime and see a breakdown of HTTP status codes.`),mdx(\"p\",null,\"Returning to our rsyslog config, we've got the following block at the bottom of the file\"),mdx(\"h1\",null,\"http logs\"),mdx(\"p\",null,'dyn_stats(name=\"http response\")'),mdx(\"p\",null,'action(type=\"mmnormalize\" ruleBase=\"/etc/rsyslog-http.rb\")'),mdx(\"p\",null,'if $!event.tags contains \"http\" then { set $foo = dyn_inc(\"http response\", $!status) }'),mdx(\"p\",null,`Here we configure a new bucket named \"http response\". Every log line that comes through\nis matched to an mmnormalize rulebase that tries to parse the log as an HTTP access log.\nIf the line matches, we pull out some fields - status code, request url, response time\netc. - and tag the log as \"http\". We use that tag decide whether we have an http log and\nincrement the counter for the status code. The rulebase contains 4 lines that look like\nthis:`),mdx(\"p\",null,\"rule=http:%remote_addr:word% %ident:word% %auth:word% \",\"[%timestamp:char-to:]\",`%]\n\"%method:word% %request:word% HTTP/%httpversion:float%\" %status:number%\n%bytes_sent:number% \"%referrer:char-to:\"%\" \"%agent:char-to:\"%\"`),mdx(\"p\",null,`These rules set up a tag (http) and a pattern to match. We set up 4 rules to account for\nextra data at the end of the log line, and leading spaces.`),mdx(\"p\",null,`The docker-compose project includes an nginx container that is configured to send logs\nto rsyslog. I've added some dummy endpoints to the configuration so that we can use curl\nto generate some web logs:`),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"/200 returns a 200 OK\"),mdx(\"li\",{parentName:\"ul\"},\"/300 returns a 301 Moved Permanently to /200\"),mdx(\"li\",{parentName:\"ul\"},\"/400 returns a 404 Not Found\"),mdx(\"li\",{parentName:\"ul\"},\"/500 returns a 500 Internal Server Error.\")),mdx(\"p\",null,`Curling these endpoints and waiting a few seconds, we should see some new metrics arrive\nin Riemann:`),mdx(\"p\",null,`riemann_1 | INFO defaultEventExecutorGroup-2-1 - riemann.config - http responses/200 = 3\nriemann_1 | INFO defaultEventExecutorGroup-2-1 - riemann.config - http responses/302 = 1\nriemann_1 | INFO defaultEventExecutorGroup-2-1 - riemann.config - http responses/404 = 1`),mdx(\"p\",null,`The code is still rough around the edges, but hopefully you can see how omriemann can\nmake it easier to monitor applications given only their log files. Next time I want to\ntalk about a third way to use omriemann: custom metrics in json.`))}MDXContent.isMDXComponent=!0;\n","scope":{}},"title":"Monitoring with Riemann and rsyslog part 2","layout":"post","author":"Bob","tags":["riemann","monitoring","elk"]},"__N_SSG":true}