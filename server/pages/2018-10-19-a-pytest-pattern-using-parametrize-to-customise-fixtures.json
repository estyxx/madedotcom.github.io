{"pageProps":{"source":{"compiledSource":"var c=Object.defineProperty,l=Object.defineProperties;var y=Object.getOwnPropertyDescriptors;var p=Object.getOwnPropertySymbols;var s=Object.prototype.hasOwnProperty,n=Object.prototype.propertyIsEnumerable;var i=(e,t,r)=>t in e?c(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,a=(e,t)=>{for(var r in t||(t={}))s.call(t,r)&&i(e,r,t[r]);if(p)for(var r of p(t))n.call(t,r)&&i(e,r,t[r]);return e},u=(e,t)=>l(e,y(t));var d=(e,t)=>{var r={};for(var o in e)s.call(e,o)&&t.indexOf(o)<0&&(r[o]=e[o]);if(e!=null&&p)for(var o of p(e))t.indexOf(o)<0&&n.call(e,o)&&(r[o]=e[o]);return r};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(r){var o=r,{components:e}=o,t=d(o,[\"components\"]);return mdx(MDXLayout,u(a(a({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,`The problem: customisable fixtures in pytest Let's say you're running along merrily with\nsome fixtures that create database objects for you:`),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-python\"}),`@pytest.fixture\ndef supplier(db):\n    s = Supplier(\n        ref=random_ref(),\n        name=random_name(),\n        country=\"US\",\n    )\n    db.add(s)\n    yield s\n    db.remove(s)\n\n\n\n@pytest.fixture()\ndef product(db, supplier):\n    p = Product(\n        ref=random_ref(),\n        name=random_name(),\n        supplier=supplier,\n        net_price=9.99,\n    )\n    db.add(p)\n    yield p\n    db.remove(p)\n`)),mdx(\"p\",null,`And now you're writing a new test and you suddenly realise you need to customise your\ndefault \"supplier\" fixture:`),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-python\"}),`def test_US_supplier_has_total_price_equal_net_price(product):\n    assert product.total_price == product.net_price\n\ndef test_EU_supplier_has_total_price_including_VAT(supplier, product):\n    supplier.country = \"FR\" # oh, this doesn't work\n    assert product.total_price == product.net_price * 1.2\n`)),mdx(\"p\",null,`For whatever reason, maybe because you need to set the supplier.country before you add\nthings to the DB, or before you instantiate product objects, you need to be able to\nadjust the country field on your supplier feature.`),mdx(\"p\",null,`Option 1: more fixtures We can just create more fixtures, and try do do a bit of DRY by\nextracting out common logic:`),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-python\"}),`def _default_supplier():\n    return Supplier(\n        ref=random_ref(),\n        name=random_name(),\n    )\n\n@pytest.fixture\ndef us_supplier(db):\n    s = _default_supplier()\n    s.country = \"US\"\n    db.add(s)\n    yield s\n    db.remove(s)\n\n@pytest.fixture\ndef eu_supplier(db):\n    s = _default_supplier()\n    s.country = \"FR\"\n    db.add(s)\n    yield s\n    db.remove(s)\n`)),mdx(\"p\",null,`That's just one way you could do it, maybe you can figure out ways to reduce the\nduplication of the db.add() stuff as well, but you are going to have to have a\ndifferent, named fixture for each customisation of Supplier, and eventually you may\ndecide that doesn't scale. us_supplier, eu_supplier, asia_supplier, ch_supplier, etc\netc, too many fixtures! I'd like just one, customisable fixture please.`),mdx(\"p\",null,`Option 2: factory fixtures Instead of a fixture returning an object directly, it can\nreturn a function that creates an object, and that function can take arguments:`),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{}),`@pytest.fixture\ndef make_supplier(db):\n    s = Supplier(\n        ref=random_ref(),\n        name=random_name(),\n    )\n\n    def _make_supplier(country):\n        s.country = country\n        db.add(s)\n        return s\n\n    yield _make_supplier\n    db.remove(s)\n`)),mdx(\"p\",null,`The problem with this is that, once you start, you tend to have to go all the way, and\nmake all of your fixture hierarchy into factory functions:`),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-python\"}),`def test_EU_supplier_has_total_price_including_VAT(make_supplier, product):\n    supplier = make_supplier(country=\"FR\")\n    product.supplier = supplier # OH, now this doesn't work, because it's too late again\n    assert product.total_price == product.net_price * 1.2\n`)),mdx(\"p\",null,\"And so...\"),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-python\"}),`@pytest.fixture\ndef make_product(db):\n    p = Product(\n        ref=random_ref(),\n        name=random_name(),\n    )\n\n    def _make_product(supplier):\n        p.supplier = supplier\n        db.add(p)\n        return p\n\n    yield _make_product\n    db.remove(p)\n\n\ndef test_EU_supplier_has_total_price_including_VAT(make_supplier, make_product):\n    supplier = make_supplier(country=\"FR\")\n    product = make_product(supplier=supplier)\n    assert product.total_price == product.net_price * 1.2\n`)),mdx(\"p\",null,`That works, but firstly now everything is a factory-fixture, which makes them more\nconvoluted, and secondly, your tests are filling up with extra calls to make_things, and\nyou're having to embed some of the domain knowledge of what-depends-on-what into your\ntests as well as your fixtures.`),mdx(\"p\",null,`Option 3: \"normal\" fixture parametrization This is a pretty cool feature of Pytest. You\nprobably already know that you can parametrize tests, injecting different values for\narguments to your test and then running the same test multiple times, once for each\nvalue:`),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-python\"}),`@pytest.mark.parametrize('n', [1, 2, 3])\ndef test_doubling(n):\n    assert n * 2 < 6 # will pass twice and fail once\n`)),mdx(\"p\",null,`A slightly less well-known feature is that you can parametrize fixtures as well. You\nneed to use the special request fixture to access your parameters:`),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-python\"}),`@pytest.fixture(params=['US', 'FR'])\ndef supplier(db, request):\n    s = Supplier(\n        ref=random_ref(),\n        name=random_name(),\n        country=request.param\n    )\n    db.add(s)\n    yield s\n    db.remove(s)\n`)),mdx(\"p\",null,`Now any test that depends on supplier, directly or indirectly, will be run twice, once\nwith supplier.country = US and once with FR.`),mdx(\"p\",null,`That's really cool for checking that a given piece of logic works in a variety of\ndifferent cases, but it's not really ideal in our case. We have to build a bunch of if\nlogic into our tests:`),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-python\"}),`def test_US_supplier_has_no_VAT_but_EU_supplier_has_total_price_including_VAT(product):\n    # this test is magically run twice, but:\n    if product.supplier.country == 'US':\n        assert product.total_price == product.net_price\n    if product.supplier.country == 'FR':\n        assert product.total_price == product.net_price * 1.2\n`)),mdx(\"p\",null,`So that's ugly, and on top of that, now every single test that depends (indirectly) on\nsupplier gets run twice, and some of those extra test runs may be totally irrelevant to\nwhat the country is.`),mdx(\"p\",null,`Presenting: using test parmetrization to override nested default-value fixtures We\nintroduce an extra fixture that holds a default value for the country field:`),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-python\"}),`@pytest.fixture()\ndef country():\n    return \"US\"\n\n\n@pytest.fixture\ndef supplier(db, country):\n    s = Supplier(\n        ref=random_ref(),\n        name=random_name(),\n        country=country,\n    )\n    db.add(s)\n    yield s\n    db.remove(s)\n`)),mdx(\"p\",null,`And then in the tests that need to change it, we can use parametrize, even though the\ncountry fixture isn't explicitly named in that test:`),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-python\"}),`@pytest.mark.parametrize('country', [\"US\"])\ndef test_US_supplier_has_total_price_equal_net_price(product):\n    assert product.total_price == product.net_price\n\n@pytest.mark.parametrize('country', [\"EU\"])\ndef test_EU_supplier_has_total_price_including_VAT(product):\n    assert product.total_price == product.net_price * 1.2\n`)),mdx(\"p\",null,`Amazing huh? The only problem is that you're now likely to build a teetering tower of\nimplicit dependencies where the only way to find out what's actually happening is to\nspend ages spelunking in conftest.py, but, hey, if you didn't like crazy nested fixture\nmagic, why are you using pytest in the first place, right?`),mdx(\"p\",null,\"Reactions and alternative suggestions on a postcard please :)\"),mdx(\"hr\",null),mdx(\"p\",null,`Cross-posted from obeythetestinggoat.com\n`,\"[http://www.obeythetestinggoat.com/a-pytest-pattern-using-parametrize-to-customise-nested-fixtures.html]\"),mdx(\"p\",null,`This blog post inspired by a pattern I first explored at PythonAnywhere\n`,\"[https://www.pythonanywhere.com/]\",`, which came up again recently; I found myself writing\ntwo successive answers to this SO post\n`,\"[https://stackoverflow.com/questions/42228895/how-to-parametrize-a-pytest-fixture]\"),mdx(\"p\",null,`Code samples can be found here\n`,\"[https://github.com/hjwp/www.obeythetestinggoat.com/tree/master/example-code/pytest_overriding_nested_fixtures_pattern]\"))}MDXContent.isMDXComponent=!0;\n","scope":{}},"title":"A pytest pattern using parametrize to customize fixtures","layout":"post","author":"Harry","tags":["python","testing","open-source"]},"__N_SSG":true}