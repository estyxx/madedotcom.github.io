{"pageProps":{"source":{"compiledSource":"var h=Object.defineProperty,m=Object.defineProperties;var c=Object.getOwnPropertyDescriptors;var n=Object.getOwnPropertySymbols;var r=Object.prototype.hasOwnProperty,i=Object.prototype.propertyIsEnumerable;var l=(e,t,s)=>t in e?h(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s,a=(e,t)=>{for(var s in t||(t={}))r.call(t,s)&&l(e,s,t[s]);if(n)for(var s of n(t))i.call(t,s)&&l(e,s,t[s]);return e},d=(e,t)=>m(e,c(t));var p=(e,t)=>{var s={};for(var o in e)r.call(e,o)&&t.indexOf(o)<0&&(s[o]=e[o]);if(e!=null&&n)for(var o of n(e))t.indexOf(o)<0&&i.call(e,o)&&(s[o]=e[o]);return s};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(s){var o=s,{components:e}=o,t=p(o,[\"components\"]);return mdx(MDXLayout,d(a(a({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,`The term DDD comes from the book by Eric Evans:\n\"`,mdx(\"a\",a({parentName:\"p\"},{href:\"https://www.amazon.co.uk/Domain-driven-Design-Tackling-Complexity-Software/dp/0321125215\"}),\"Domain-Driven Design: Tackling Complexity in the Heart of Software\"),`\n\". In his book he describes a set of practices that aim to help us build maintainable,\nrich, software systems that solve customer's problems. The book is 560 pages of dense\ninsight, so you'll pardon me if my summary elides some details, but in brief he\nsuggests:`),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},`Listen very carefully to your domain experts - the people whose job you're automating\nor assisting in software.`),mdx(\"li\",{parentName:\"ul\"},`Learn the jargon that they use, and help them to come up with new jargon, so that\nevery concept in their mental model is named by a single precise term.`),mdx(\"li\",{parentName:\"ul\"},`Use those terms to model your software; the nouns and verbs of the domain expert are\nthe classes and methods you should use in modelling.`),mdx(\"li\",{parentName:\"ul\"},`Whenever there is a discrepancy between your shared understanding of the domain, go\nand talk to the domain experts again, and then refactor aggressively.`)),mdx(\"p\",null,`This sounds great in theory, but in practice we often find that our business logic\nescapes from our model objects; we end up with logic bleeding into controllers, or into\nfat \"manager\" classes. We find that refactoring becomes difficult: we can't split a\nlarge and important class, because that would seriously impact the database schema; or\nwe can't rewrite the internals of an algorithm because it has become tightly coupled to\ncode that exists for a different use-case. The good news is that these problems can be\navoided, since they are caused by a lack of organisation in the codebase. In fact, the\ntools to solve these problems take up half of the DDD book, but it can be be difficult\nto understand how to use them together in the context of a complete system.`),mdx(\"p\",null,`I want to use this series to introduce an architectural style called\n`,mdx(\"a\",a({parentName:\"p\"},{href:\"http://wiki.c2.com/?PortsAndAdaptersArchitecture\"}),\"Ports and Adapters\"),`, and a design\npattern named\n`,mdx(\"a\",a({parentName:\"p\"},{href:\"https://matthiasnoback.nl/2015/01/responsibilities-of-the-command-bus/\"}),\"Command Handler\"),`.\nI'll be explaining the patterns in Python because that's the language that I use\nday-to-day, but the concepts are applicable to any OO language, and can be massaged to\nwork perfectly in a functional context. There might be a lot more layering and\nabstraction than you're used to, especially if you're coming from a Django background or\nsimilar, but please bear with me. In exchange for a more complex system at the outset,\nwe can avoid much of our\n`,mdx(\"a\",a({parentName:\"p\"},{href:\"http://wiki.c2.com/?AccidentalComplexity\"}),\"accidental complexity\"),\" later.\"),mdx(\"p\",null,`The system we're going to build is an issue management system, for use by a helpdesk.\nWe're going to be replacing an existing system, which consists of an HTML form that\nsends an email. The emails go into a mailbox, and helpdesk staff go through the mails\ntriaging problems and picking up problems that they can solve. Sometimes issues get\noverlooked for a long time, and the helpdesk team have invented a complex system of\npost-it notes and whiteboard layouts to track work in progress. For a while this system\nhas worked pretty well but, as the system gets busier, the cracks are beginning to show.`),mdx(\"p\",null,`Our first conversation with the domain expert \"What's the first step in the process?\"\nyou ask, \"How do tickets end up in the mail box?\".`),mdx(\"p\",null,`\"Well, the first thing that happens is the user goes to the web page, and they fill out\nsome details, and report an issue. That sends an email into the issue log and then we\npick issues from the log each morning\".`),mdx(\"p\",null,`\"So when a user reports an issue, what's the minimal set of data that you need from\nthem?\"`),mdx(\"p\",null,`\"We need to know who they are, so their name, and email I guess. Uh... and the problem\ndescription. They're supposed to add a category, but they never do, and we used to have\na priority, but everyone set their issue to EXTREMELY URGENT, so it was useless.`),mdx(\"p\",null,'\"But a category and priority would help you to triage things?\"'),mdx(\"p\",null,'\"Yes, that would be really helpful if we could get users to set them properly.\"'),mdx(\"p\",null,\"This gives us our first use case: As a user, I want to be able to report a new issue.\"),mdx(\"p\",null,`Okay, before we get to the code, let's talk about architecture. The architecture of a\nsoftware system is the overall structure - the choice of language, technology, and\ndesign patterns that organise the code and satisfy our\n`,mdx(\"a\",a({parentName:\"p\"},{href:\"https://en.wikipedia.org/wiki/Non-functional_requirement\"}),\"constraints\"),`. For our\narchitecture, we're going to try and stick with three principles:`),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},`We will always define where our use-cases begin and end. We won't have business\nprocesses that are strewn all over the codebase.`),mdx(\"li\",{parentName:\"ol\"},`We will\n`,mdx(\"a\",a({parentName:\"li\"},{href:\"https://en.wikipedia.org/wiki/Dependency_inversion_principle\"}),\"depend on abstractions\"),`\n, and not on concrete implementations.`),mdx(\"li\",{parentName:\"ol\"},`We will treat glue code as distinct from business logic, and put it in an\nappropriate place.`)),mdx(\"p\",null,\"Firstly we start with the \",mdx(\"strong\",{parentName:\"p\"},\"domain model\"),`. The domain model encapsulates our shared\nunderstanding of the problem, and uses the terms we agreed with the domain experts. In\nkeeping with principle #2 we will define abstractions for any infrastructural or\ntechnical concerns and use those in our model. For example, if we need to send an email,\nor save an entity to a database, we will do so through an abstraction that captures our\nintent. In this series we'll create a separate python package for our domain model so\nthat we can be sure it has no dependencies on the other layers of the system.\nMaintaining this rule strictly will make it easier to test and refactor our system,\nsince our domain models aren't tangled up with messy details of databases and http\ncalls.`),mdx(\"p\",null,\"Around the outside of our domain model we place \",mdx(\"strong\",{parentName:\"p\"},\"services\"),`. These are stateless\nobjects that do stuff to the domain. In particular, for this system, our command\nhandlers are part of the service layer.`),mdx(\"p\",null,\"Finally, we have our \",mdx(\"strong\",{parentName:\"p\"},\"adapter\"),` layer. This layer contains code that drives the service\nlayer, or provides services to the domain model. For example, our domain model may have\nan abstraction for talking to the database, but the adapter layer provides a concrete\nimplementation. Other adapters might include a Flask API, or our set of unit tests, or a\ncelery event queue. All of these adapters connect our application to the outside world.`),mdx(\"p\",null,`In keeping with our first principle, we're going to define a boundary for this use case\nand create our first `,mdx(\"em\",{parentName:\"p\"},\"Command Handler\"),`. A command handler is an object that orchestrates\na business process. It does the boring work of fetching the right objects, and invoking\nthe right methods on them. It's similar to the concept of a Controller in an MVC\narchitecture.`),mdx(\"p\",null,\"First, we create a \",mdx(\"em\",{parentName:\"p\"},\"Command\"),\" object.\"),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-python\"}),`class ReportIssueCommand(NamedTuple):\n        reporter_name: str\n        reporter_email: str\n        problem_description: str\n`)),mdx(\"p\",null,`A command object is a small object that represents a state-changing action that can\nhappen in the system. Commands have no behaviour, they're pure data structures. There's\nno reason why you have to represent them with classes, since all they need is a name and\na bag of data, but a NamedTuple is a nice compromise between simplicity and convenience.\nCommands are instructions from an external agent (a user, a cron job, another service\netc.) and have names in the imperative tense, for example:`),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"ReportIssue\"),mdx(\"li\",{parentName:\"ul\"},\"PrepareUploadUri\"),mdx(\"li\",{parentName:\"ul\"},\"CancelOutstandingOrders\"),mdx(\"li\",{parentName:\"ul\"},\"RemoveItemFromCart\"),mdx(\"li\",{parentName:\"ul\"},\"OpenLoginSession\"),mdx(\"li\",{parentName:\"ul\"},\"PlaceCustomerOrder\"),mdx(\"li\",{parentName:\"ul\"},\"BeginPaymentProcess\")),mdx(\"p\",null,`We should try to avoid the verbs Create, Update, or Delete (and their synonyms) because\nthose are technical implementations. When we listen to our domain experts, we often find\nthat there is a better word for the operation we're trying to model. If all of your\ncommands are named \"CreateIssue\", \"UpdateCart\", \"DeleteOrders\", then you're probably not\npaying enough attention to the language that your stakeholders are using.`),mdx(\"p\",null,`The command objects belong to the domain, and they express the API of your domain. If\nevery state-changing action is performed via a command handler, then the list of\nCommands is the complete list of supported operations in your domain model. This has two\nmajor benefits:`),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},`If the only way to change state in the system is through a command, then the list of\ncommands tells me all the things I need to test. There are no other code paths that\ncan modify data.`),mdx(\"li\",{parentName:\"ol\"},`Because our commands are lightweight, logic-free objects, we can create them from an\nHTTP post, or a celery task, or a command line csv reader, or a unit test. They form\na simple and stable API for our system that does not depend on any implementation\ndetails and can be invoked in multiple ways.`)),mdx(\"p\",null,\"In order to process our new command, we'll need to create a command handler.\"),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-python\"}),`class ReportIssueCommandHandler:\n    def __init__(self, issue_log):\n        self.issue_log = issue_log\n\n    def __call__(self, cmd):\n        reported_by = IssueReporter(\n            cmd.reporter_name,\n            cmd.reporter_email)\n        issue = Issue(reported_by, cmd.problem_description)\n        self.issue_log.add(issue)\n`)),mdx(\"p\",null,`Command handlers are stateless objects that orchestrate the behaviour of a system. They\nare a kind of glue code, and manage the boring work of fetching and saving objects, and\nthen notifying other parts of the system. In keeping with principle #3, we keep this in\na separate layer. To satisfy principle #1, each use case is a separate command handler\nand has a clearly defined beginning and end. Every command is handled by exactly one\ncommand handler.`),mdx(\"p\",null,\"In general all command handlers will have the same structure:\"),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},\"Fetch the current state from our persistent storage.\"),mdx(\"li\",{parentName:\"ol\"},\"Update the current state.\"),mdx(\"li\",{parentName:\"ol\"},\"Persist the new state.\"),mdx(\"li\",{parentName:\"ol\"},\"Notify any external systems that our state has changed.\")),mdx(\"p\",null,`We will usually avoid if statements, loops, and other such wizardry in our handlers, and\nstick to a single possible line of execution. Command handlers are boring glue code.\nSince our command handlers are just glue code, we won't put any business logic into\nthem - they shouldn't be making any business decisions. For example, let's skip ahead a\nlittle to a new command handler:`),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-python\"}),`class MarkIssueAsResolvedHandler:\n    def __init__(self, issue_log):\n        self.issue_log = issue_log\n\n    def __call__(self, cmd):\n        issue = self.issue_log.get(cmd.issue_id)\n        # the following line encodes a business rule\n        if (issue.state != IssueStatus.Resolved):\n            issue.mark_as_resolved(cmd.resolution)\n`)),mdx(\"p\",null,`This handler violates our glue-code principle because it encodes a business rule: \"If an\nissue is already resolved, then it can't be resolved a second time\". This rule belongs\nin our domain model, probably in the `,mdx(\"inlineCode\",{parentName:\"p\"},\"mark_as_resolved\"),\" method of our \",mdx(\"inlineCode\",{parentName:\"p\"},\"Issue\"),` object. I\ntend to use classes for my command handlers, and to invoke them with the call magic\nmethod, but a function is perfectly valid as a handler, too. The major reason to prefer\na class is that it can make dependency management a little easier, but the two\napproaches are completely equivalent. For example, we could rewrite our\n`,mdx(\"inlineCode\",{parentName:\"p\"},\"ReportIssueHandler\"),\" like this:\"),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-python\"}),`def ReportIssue(issue_log, cmd):\n    reported_by = IssueReporter(\n        cmd.reporter_name,\n        cmd.reporter_email)\n    issue = Issue(reported_by, cmd.problem_description)\n    issue_log.add(issue)\n`)),mdx(\"p\",null,`If magic methods make you feel queasy, you can define a handler to be a class that\nexposes a handle method like this:`),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-python\"}),`class ReportIssueHandler:\n    def handle(self, cmd):\n       ...\n`)),mdx(\"p\",null,\"However you structure them, the important ideas of commands and handlers are:\"),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},\"Commands are logic-free data structures with a name and a bunch of values.\"),mdx(\"li\",{parentName:\"ol\"},`They form a stable, simple API that describes what our system can do, and doesn't\ndepend on any implementation details.`),mdx(\"li\",{parentName:\"ol\"},\"Each command can be handled by exactly one handler.\"),mdx(\"li\",{parentName:\"ol\"},\"Each command instructs the system to run through one use case.\"),mdx(\"li\",{parentName:\"ol\"},`A handler will usually do the following steps: get state, change state, persist\nstate, notify other parties that state was changed.`)),mdx(\"p\",null,`Let's take a look at the complete system, I'm concatenating all the files into a single\ncode listing for each of grokking, but in the\n`,mdx(\"a\",a({parentName:\"p\"},{href:\"https://github.com/bobthemighty/blog-code-samples/tree/master/ports-and-adapters/01\"}),\"git repository\"),`\nI'm splitting the layers of the system into separate packages. In the real world, I\nwould probably use a single python package for the whole app, but in other languages -\nJava, C#, C++ - I would usually have a single binary for each layer. Splitting the\npackages up this way makes it easier to understand how the dependencies work.`),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-python\"}),`from typing import NamedTuple\nfrom expects import expect, have_len, equal\n\n# Domain model\n\nclass IssueReporter:\n    def __init__(self, name, email):\n        self.name = name\n        self.email = email\n\n\nclass Issue:\n    def __init__(self, reporter, description):\n        self.description = description\n        self.reporter = reporter\n\n\nclass IssueLog:\n    def add(self, issue):\n        pass\n\n\nclass ReportIssueCommand(NamedTuple):\n    reporter_name: str\n    reporter_email: str\n    problem_description: str\n\n\n# Service Layer\n\nclass ReportIssueHandler:\n\n    def __init__(self, issue_log):\n        self.issue_log = issue_log\n\n    def __call__(self, cmd):\n        reported_by = IssueReporter(\n            cmd.reporter_name,\n            cmd.reporter_email)\n        issue = Issue(reported_by, cmd.problem_description)\n        self.issue_log.add(issue)\n\n\n# Adapters\n\nclass FakeIssueLog(IssueLog):\n\n    def __init__(self):\n        self.issues = []\n\n    def add(self, issue):\n        self.issues.append(issue)\n\n    def get(self, id):\n        return self.issues[id]\n\n    def __len__(self):\n        return len(self.issues)\n\n    def __getitem__(self, idx):\n        return self.issues[idx]\n\n\nemail = \"bob@example.org\"\nname = \"bob\"\ndesc = \"My mouse won't move\"\n\n\nclass When_reporting_an_issue:\n\n    def given_an_empty_issue_log(self):\n        self.issues = FakeIssueLog()\n\n    def because_we_report_a_new_issue(self):\n        handler = ReportIssueHandler(self.issues)\n        cmd = ReportIssueCommand(name, email, desc)\n\n        handler(cmd)\n\n    def the_handler_should_have_created_a_new_issue(self):\n        expect(self.issues).to(have_len(1))\n\n    def it_should_have_recorded_the_issuer(self):\n        expect(self.issues[0].reporter.name).to(equal(name))\n        expect(self.issues[0].reporter.email).to(equal(email))\n\n    def it_should_have_recorded_the_description(self):\n        expect(self.issues[0].description).to(equal(desc))\n`)),mdx(\"p\",null,`There's not a lot of functionality here, and our issue log has a couple of problems,\nfirstly there's no way to see the issues in the log yet, and secondly we'll lose all of\nour data every time we restart the process. We'll fix the second of those in the next\npart:\n`,mdx(\"a\",a({parentName:\"p\"},{href:\"https://io.made.com/blog/2017-09-08-repository-and-unit-of-work-pattern-in-python.html\"}),\"Repository And Unit Of Work Pattern In Python\"),\".\"))}MDXContent.isMDXComponent=!0;\n","scope":{}},"title":"Introducing the command handler","layout":"post","author":"Bob","categories":["ports & adapters"],"tags":["python","architecture"]},"__N_SSG":true}