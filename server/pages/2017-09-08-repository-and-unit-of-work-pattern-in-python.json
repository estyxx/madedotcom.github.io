{"pageProps":{"source":{"compiledSource":"var h=Object.defineProperty,p=Object.defineProperties;var c=Object.getOwnPropertyDescriptors;var r=Object.getOwnPropertySymbols;var i=Object.prototype.hasOwnProperty,n=Object.prototype.propertyIsEnumerable;var l=(e,s,o)=>s in e?h(e,s,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[s]=o,t=(e,s)=>{for(var o in s||(s={}))i.call(s,o)&&l(e,o,s[o]);if(r)for(var o of r(s))n.call(s,o)&&l(e,o,s[o]);return e},d=(e,s)=>p(e,c(s));var u=(e,s)=>{var o={};for(var a in e)i.call(e,a)&&s.indexOf(a)<0&&(o[a]=e[a]);if(e!=null&&r)for(var a of r(e))s.indexOf(a)<0&&n.call(e,a)&&(o[a]=e[a]);return o};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(o){var a=o,{components:e}=a,s=u(a,[\"components\"]);return mdx(MDXLayout,d(t(t({},layoutProps),s),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,`In the\n`,mdx(\"a\",t({parentName:\"p\"},{href:\"http://io.made.com/blog/2017-09-07-introducing-command-handler.html\"}),\"previous part\"),` of\nthis series we built a toy system that could add a new Issue to an IssueLog, but had no\nreal behaviour of its own, and would lose its data every time the application restarted.\nWe're going to extend it a little by introducing some patterns for persistent data\naccess, and talk a little more about the ideas underlying ports and adapters\narchitectures. To recap, we're abiding by three principles:`),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},\"Clearly define the boundaries of our use cases.\"),mdx(\"li\",{parentName:\"ol\"},\"Depend on abstractions, not on concrete implementation.\"),mdx(\"li\",{parentName:\"ol\"},\"Identify glue code as distinct from domain logic and put it into its own layer.\")),mdx(\"p\",null,\"In our command handler, we wrote the following code:\"),mdx(\"pre\",null,mdx(\"code\",t({parentName:\"pre\"},{className:\"language-python\"}),`reporter = IssueReporter(cmd.reporter_name, cmd.reporter_email)\nissue = Issue(reporter, cmd.problem_description)\nissue_log.add(issue)\n`)),mdx(\"p\",null,`The IssueLog is a term from our conversation with the domain expert. It's the place that\nthey record the list of all issues. This is part of the jargon used by our customers,\nand so it clearly belongs in the domain, but it's also the ideal abstraction for a data\nstore. How can we modify the code so that our newly created Issue will be persisted? We\ndon't want our IssueLog to depend on the database, because that's a violation of\nprinciple #2. This is the question that leads us to the ports & adapters architecture.`),mdx(\"p\",null,`In a ports and adapters architecture, we build a pure domain that exposes ports. A port\nis a way for data to get into, or out of, the domain model. In this system, the IssueLog\nis a port. Ports are connected to the external world by Adapters. In the previous code\nsample, the FakeIssueLog is an adapter: it provides a service to the system by\nimplementing an interface.`),mdx(\"p\",null,`Let's use a real-world analogy. Imagine we have a circuit that detects current over some\nthreshold. If the threshold is reached, the circuit outputs a signal. Into our circuit\nwe attach two ports, one for current in, and one for current out. The input and output\nchannels are part of our circuit: without them, the circuit is useless.`),mdx(\"pre\",null,mdx(\"code\",t({parentName:\"pre\"},{className:\"language-python\"}),`class ThresholdDetectionCircuit:\n\n    arbitrary_threshold = 4\n\n    def __init__(self, input: ReadablePort, output: WriteablePort):\n        self.input = input\n        self.output = output\n\n    def read_from_input(self):\n        next_value = self.input.read()\n        if next_value > self.arbitrary_threshold:\n            self.output.write(1)\n`)),mdx(\"p\",null,`Because we had the great foresight to use standardised ports, we can plug any number of\ndifferent devices into our circuit. For example, we could attach a light-detector to the\ninput and a buzzer to the output, or we could attach a dial to the input, and a light to\nthe output, and so on.`),mdx(\"pre\",null,mdx(\"code\",t({parentName:\"pre\"},{className:\"language-python\"}),`class LightDetector(ReadablePort):\n    def read(self):\n        return self.get_light_amplitude()\n\nclass Buzzer(WriteablePort):\n    def write(self, value):\n        if value > 0:\n            self.make_infuriating_noise()\n\n\nclass Dial(ReadablePort):\n    def read(self):\n        return self.current_value\n\nclass Light(WriteablePort):\n    def write(self, value):\n        if value > 0:\n            self.on = True\n        else:\n            self.on = False\n`)),mdx(\"p\",null,`Considered in isolation, this is just an example of good OO practice: we are extending\nour system through `,mdx(\"strong\",{parentName:\"p\"},\"composition\"),`. What makes this a ports-and-adapters architecture is\nthe idea that there is an internal world consisting of the domain model (our\nThresholdDetectionCircuit), and an external world that drives the domain model through\nwell-defined ports. How does all of this relate to databases?`),mdx(\"pre\",null,mdx(\"code\",t({parentName:\"pre\"},{className:\"language-python\"}),`from SqlAlchemy import Session\n\nclass SqlAlchemyIssueLog (IssueLog):\n\n    def __init__(self, session: Session):\n        self.session = session\n\n    def add(self, issue):\n        self.session.add(issue)\n\n\nclass TextFileIssueLog (IssueLog):\n\n    def __init__(self, path):\n        self.path = path\n\n    def add(self, issue):\n        with open(self.path, 'w') as f:\n            json.dump(f)\n`)),mdx(\"p\",null,`By analogy to our circuit example, the IssueLog is a WriteablePort - it's a way for us\nto get data out of the system. SqlAlchemy and the file system are two types of adapter\nthat we can plug in, just like the Buzzer or Light classes. In fact, the IssueLog is an\ninstance of a common design pattern: it's a\n`,mdx(\"a\",t({parentName:\"p\"},{href:\"https://martinfowler.com/eaaCatalog/repository.html\"}),\"Repository\"),`. A repository is an\nobject that hides the details of persistent storage by presenting us with an interface\nthat looks like a collection. We should be able to add new things to the repository, and\nget things out of the repository, and that's essentially it.`),mdx(\"p\",null,\"Let's look at a simple repository pattern.\"),mdx(\"pre\",null,mdx(\"code\",t({parentName:\"pre\"},{className:\"language-python\"}),`class FooRepository:\n    def __init__(self, db_session):\n        self.session = db_session\n\n    def add_new_item(self, item):\n        self.db_session.add(item)\n\n    def get_item(self, id):\n        return self.db_session.get(Foo, id)\n\n    def find_foos_by_latitude(self, latitude):\n        return self.session.query(Foo).\\\\\n                filter(foo.latitude == latitude)\n`)),mdx(\"p\",null,`We expose a few methods, one to add new items, one to get items by their id, and a third\nto find items by some criterion. This FooRepository is using a\n`,mdx(\"a\",t({parentName:\"p\"},{href:\"http://docs.sqlalchemy.org/en/latest/orm/session_basics.html\"}),\"SqlAlchemy session\"),`\nobject, so it's part of our Adapter layer. We could define a different adapter for use\nin unit tests.`),mdx(\"pre\",null,mdx(\"code\",t({parentName:\"pre\"},{className:\"language-python\"}),`class FooRepository:\n    def __init__(self, db_session):\n        self.items = []\n\n    def add_new_item(self, item):\n        self.items.append(item)\n\n    def get_item(self, id):\n        return next((item for item in self.items\n                          if item.id == id))\n\n    def find_foos_by_latitude(self, latitude):\n        return (item for item in self.items\n                     if item.latitude == latitude)\n`)),mdx(\"p\",null,`This adapter works just the same as the one backed by a real database, but does so\nwithout any external state. This allows us to test our code without resorting to\nSetup/Teardown scripts on our database, or monkey patching our ORM to return hard-coded\nvalues. We just plug a different adapter into the existing port. As with the\nReadablePort and WriteablePort, the simplicity of this interface makes it simple for us\nto plug in different implementations.`),mdx(\"p\",null,`The repository gives us read/write access to objects in our data store, and is commonly\nused with another pattern, the\n`,mdx(\"a\",t({parentName:\"p\"},{href:\"https://martinfowler.com/eaaCatalog/unitOfWork.html\"}),\"Unit of Work\"),`. A unit of work\nrepresents a bunch of things that all have to happen together. It usually allows us to\ncache objects in memory for the lifetime of a request so that we don't need to make\nrepeated calls to the database. A unit of work is responsible for doing dirty checks on\nour objects, and flushing any changes to state at the end of a request.`),mdx(\"p\",null,\"What does a unit of work look like?\"),mdx(\"pre\",null,mdx(\"code\",t({parentName:\"pre\"},{className:\"language-python\"}),`class SqlAlchemyUnitOfWorkManager(UnitOfWorkManager):\n    \"\"\"The Unit of work manager returns a new unit of work.\n       Our UOW is backed by a sql alchemy session whose\n       lifetime can be scoped to a web request, or a\n       long-lived background job.\"\"\"\n    def __init__(self, session_maker):\n        self.session_maker = session_maker\n\n    def start(self):\n        return SqlAlchemyUnitOfWork(self.session_maker)\n\n\nclass SqlAlchemyUnitOfWork(UnitOfWork):\n    \"\"\"The unit of work captures the idea of a set of things that\n       need to happen together.\n\n       Usually, in a relational database,\n       one unit of work == one database transaction.\"\"\"\n\n    def __init__(self, sessionfactory):\n        self.sessionfactory = sessionfactory\n\n    def __enter__(self):\n        self.session = self.sessionfactory()\n        return self\n\n    def __exit__(self, type, value, traceback):\n        self.session.close()\n\n    def commit(self):\n        self.session.commit()\n\n    def rollback(self):\n        self.session.rollback()\n\n    # I tend to put my repositories onto my UOW\n    # for convenient access.\n    @property\n    def issues(self):\n        return IssueRepository(self.session)\n`)),mdx(\"p\",null,`This code is taken from a current production system - the code to implement these\npatterns really isn't complex. The only thing missing here is some logging and error\nhandling in the commit method. Our unit-of-work manager creates a new unit-of-work, or\ngives us an existing one depending on how we've configured SqlAlchemy. The unit of work\nitself is just a thin layer over the top of SqlAlchemy that gives us explicit rollback\nand commit points. Let's revisit our first command handler and see how we might use\nthese patterns together.`),mdx(\"pre\",null,mdx(\"code\",t({parentName:\"pre\"},{className:\"language-python\"}),`class ReportIssueHandler:\n    def __init__(self, uowm:UnitOfWorkManager):\n        self.uowm = uowm\n\n    def handle(self, cmd):\n        with self.uowm.start() as unit_of_work:\n            reporter = IssueReporter(cmd.reporter_name, cmd.reporter_email)\n            issue = Issue(reporter, cmd.problem_description)\n            unit_of_work.issues.add(issue)\n            unit_of_work.commit()\n`)),mdx(\"p\",null,`Our command handler looks more or less the same, except that it's now responsible for\nstarting a unit-of-work, and committing the unit-of-work when it has finished. This is\nin keeping with our rule #1 - we will clearly define the beginning and end of use cases.\nWe know for a fact that only one object is being loaded and modified here, and our\ndatabase transaction is kept short. Our handler depends on an abstraction - the\nUnitOfWorkManager, and doesn't care if that's a test-double or a SqlAlchemy session, so\nthat's rule #2 covered. Lastly, this code is painfully boring because it's just glue.\nWe're moving all the dull glue out to the edges of our system so that we can write our\ndomain model in any way that we like: rule #3 observed.`),mdx(\"p\",null,mdx(\"a\",t({parentName:\"p\"},{href:\"https://github.com/bobthemighty/blog-code-samples/tree/master/ports-and-adapters/02\"}),\"The code sample for this part\"),`\nadds a couple of new packages -\n`,mdx(\"a\",t({parentName:\"p\"},{href:\"http://pycon-2012-notes.readthedocs.io/en/latest/fast_tests_slow_tests.html\"}),\"one for slow tests\"),`\n(tests that go over a network, or to a real file system), and one for our adapters. We\nhaven't added any new features yet, but we've added a test that shows we can insert an\nIssue into a sqlite database through our command handler and unit of work. Notice that\nall of the ORM code is in one module (issues.adapters.orm) and that it depends on our\ndomain model, not the other way around. Our domain objects don't inherit from\nSqlAlchemy's declarative base. We're beginning to get some sense of what it means to\nhave the domain on the \"inside\" of a system, and the infrastructural code on the\noutside.`),mdx(\"p\",null,`Our unit test has been updated to use a unit of work, and we can now test that we insert\nan issue into our issue log, and commit the unit of work, without having a dependency on\nany actual implementation details. We could completely delete SqlAlchemy from our code\nbase, and our unit tests would continue to work, because we have a pure domain model and\nwe expose abstract ports from our service layer.`),mdx(\"pre\",null,mdx(\"code\",t({parentName:\"pre\"},{className:\"language-python\"}),`class When_reporting_an_issue:\n\n    def given_an_empty_unit_of_work(self):\n        self.uow = FakeUnitOfWork()\n\n    def because_we_report_a_new_issue(self):\n        handler = ReportIssueHandler(self.uow)\n        cmd = ReportIssueCommand(name, email, desc)\n\n        handler.handle(cmd)\n\n    def the_handler_should_have_created_a_new_issue(self):\n        expect(self.uow.issues).to(have_len(1))\n\n    def it_should_have_recorded_the_issue(self):\n        expect(self.uow.issues[0].reporter.name).to(equal(name))\n        expect(self.uow.issues[0].reporter.email).to(equal(email))\n\n    def it_should_have_recorded_the_description(self):\n        expect(self.uow.issues[0].description).to(equal(desc))\n\n    def it_should_have_committed_the_unit_of_work(self):\n        expect(self.uow.was_committed).to(be_true)\n`)),mdx(\"p\",null,mdx(\"a\",t({parentName:\"p\"},{href:\"http://io.made.com/blog/2017-09-13-commands-and-queries-handlers-and-views.html\"}),\"Next time\"),`\nwe'll look at how to get data back out of the system.`))}MDXContent.isMDXComponent=!0;\n","scope":{}},"date":"2017-09-08","title":"Repositoriy and unit of work pattern in python","layout":"post","author":"Bob","categories":["ports & adapters"],"tags":["python","architecture"]},"__N_SSG":true}