<!DOCTYPE html><html><head><link rel="icon" href="/made_logo.png"/><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Why use domain events</title><meta name="next-head-count" content="3"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-f8fe1f0eb2299c5d.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-208998328ec77b24.js" defer=""></script><script src="/_next/static/chunks/pages/_app-b685dc8eb7ea53b1.js" defer=""></script><script src="/_next/static/chunks/pages/%5Bslug%5D-6f1b99546b30e54e.js" defer=""></script><script src="/_next/static/Wh2OZ5RTgu9TtehCz94O1/_buildManifest.js" defer=""></script><script src="/_next/static/Wh2OZ5RTgu9TtehCz94O1/_ssgManifest.js" defer=""></script><script src="/_next/static/Wh2OZ5RTgu9TtehCz94O1/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><style data-emotion="css-global o7558t">:host,:root{--chakra-ring-inset:var(--chakra-empty,/*!*/ /*!*/);--chakra-ring-offset-width:0px;--chakra-ring-offset-color:#fff;--chakra-ring-color:rgba(66, 153, 225, 0.6);--chakra-ring-offset-shadow:0 0 #0000;--chakra-ring-shadow:0 0 #0000;--chakra-space-x-reverse:0;--chakra-space-y-reverse:0;--chakra-colors-transparent:transparent;--chakra-colors-current:currentColor;--chakra-colors-black:#000000;--chakra-colors-white:#FFFFFF;--chakra-colors-whiteAlpha-50:rgba(255, 255, 255, 0.04);--chakra-colors-whiteAlpha-100:rgba(255, 255, 255, 0.06);--chakra-colors-whiteAlpha-200:rgba(255, 255, 255, 0.08);--chakra-colors-whiteAlpha-300:rgba(255, 255, 255, 0.16);--chakra-colors-whiteAlpha-400:rgba(255, 255, 255, 0.24);--chakra-colors-whiteAlpha-500:rgba(255, 255, 255, 0.36);--chakra-colors-whiteAlpha-600:rgba(255, 255, 255, 0.48);--chakra-colors-whiteAlpha-700:rgba(255, 255, 255, 0.64);--chakra-colors-whiteAlpha-800:rgba(255, 255, 255, 0.80);--chakra-colors-whiteAlpha-900:rgba(255, 255, 255, 0.92);--chakra-colors-blackAlpha-50:rgba(0, 0, 0, 0.04);--chakra-colors-blackAlpha-100:rgba(0, 0, 0, 0.06);--chakra-colors-blackAlpha-200:rgba(0, 0, 0, 0.08);--chakra-colors-blackAlpha-300:rgba(0, 0, 0, 0.16);--chakra-colors-blackAlpha-400:rgba(0, 0, 0, 0.24);--chakra-colors-blackAlpha-500:rgba(0, 0, 0, 0.36);--chakra-colors-blackAlpha-600:rgba(0, 0, 0, 0.48);--chakra-colors-blackAlpha-700:rgba(0, 0, 0, 0.64);--chakra-colors-blackAlpha-800:rgba(0, 0, 0, 0.80);--chakra-colors-blackAlpha-900:rgba(0, 0, 0, 0.92);--chakra-colors-gray-50:#F7FAFC;--chakra-colors-gray-100:#EDF2F7;--chakra-colors-gray-200:#E2E8F0;--chakra-colors-gray-300:#CBD5E0;--chakra-colors-gray-400:#A0AEC0;--chakra-colors-gray-500:#718096;--chakra-colors-gray-600:#4A5568;--chakra-colors-gray-700:#2D3748;--chakra-colors-gray-800:#1A202C;--chakra-colors-gray-900:#171923;--chakra-colors-red-50:#FFF5F5;--chakra-colors-red-100:#FED7D7;--chakra-colors-red-200:#FEB2B2;--chakra-colors-red-300:#FC8181;--chakra-colors-red-400:#F56565;--chakra-colors-red-500:#E53E3E;--chakra-colors-red-600:#C53030;--chakra-colors-red-700:#9B2C2C;--chakra-colors-red-800:#822727;--chakra-colors-red-900:#63171B;--chakra-colors-orange-50:#FFFAF0;--chakra-colors-orange-100:#FEEBC8;--chakra-colors-orange-200:#FBD38D;--chakra-colors-orange-300:#F6AD55;--chakra-colors-orange-400:#ED8936;--chakra-colors-orange-500:#DD6B20;--chakra-colors-orange-600:#C05621;--chakra-colors-orange-700:#9C4221;--chakra-colors-orange-800:#7B341E;--chakra-colors-orange-900:#652B19;--chakra-colors-yellow-50:#FFFFF0;--chakra-colors-yellow-100:#FEFCBF;--chakra-colors-yellow-200:#FAF089;--chakra-colors-yellow-300:#F6E05E;--chakra-colors-yellow-400:#ECC94B;--chakra-colors-yellow-500:#D69E2E;--chakra-colors-yellow-600:#B7791F;--chakra-colors-yellow-700:#975A16;--chakra-colors-yellow-800:#744210;--chakra-colors-yellow-900:#5F370E;--chakra-colors-green-50:#F0FFF4;--chakra-colors-green-100:#C6F6D5;--chakra-colors-green-200:#9AE6B4;--chakra-colors-green-300:#68D391;--chakra-colors-green-400:#48BB78;--chakra-colors-green-500:#38A169;--chakra-colors-green-600:#2F855A;--chakra-colors-green-700:#276749;--chakra-colors-green-800:#22543D;--chakra-colors-green-900:#1C4532;--chakra-colors-teal-50:#E6FFFA;--chakra-colors-teal-100:#B2F5EA;--chakra-colors-teal-200:#81E6D9;--chakra-colors-teal-300:#4FD1C5;--chakra-colors-teal-400:#38B2AC;--chakra-colors-teal-500:#319795;--chakra-colors-teal-600:#2C7A7B;--chakra-colors-teal-700:#285E61;--chakra-colors-teal-800:#234E52;--chakra-colors-teal-900:#1D4044;--chakra-colors-blue-50:#ebf8ff;--chakra-colors-blue-100:#bee3f8;--chakra-colors-blue-200:#90cdf4;--chakra-colors-blue-300:#63b3ed;--chakra-colors-blue-400:#4299e1;--chakra-colors-blue-500:#3182ce;--chakra-colors-blue-600:#2b6cb0;--chakra-colors-blue-700:#2c5282;--chakra-colors-blue-800:#2a4365;--chakra-colors-blue-900:#1A365D;--chakra-colors-cyan-50:#EDFDFD;--chakra-colors-cyan-100:#C4F1F9;--chakra-colors-cyan-200:#9DECF9;--chakra-colors-cyan-300:#76E4F7;--chakra-colors-cyan-400:#0BC5EA;--chakra-colors-cyan-500:#00B5D8;--chakra-colors-cyan-600:#00A3C4;--chakra-colors-cyan-700:#0987A0;--chakra-colors-cyan-800:#086F83;--chakra-colors-cyan-900:#065666;--chakra-colors-purple-50:#FAF5FF;--chakra-colors-purple-100:#E9D8FD;--chakra-colors-purple-200:#D6BCFA;--chakra-colors-purple-300:#B794F4;--chakra-colors-purple-400:#9F7AEA;--chakra-colors-purple-500:#805AD5;--chakra-colors-purple-600:#6B46C1;--chakra-colors-purple-700:#553C9A;--chakra-colors-purple-800:#44337A;--chakra-colors-purple-900:#322659;--chakra-colors-pink-50:#FFF5F7;--chakra-colors-pink-100:#FED7E2;--chakra-colors-pink-200:#FBB6CE;--chakra-colors-pink-300:#F687B3;--chakra-colors-pink-400:#ED64A6;--chakra-colors-pink-500:#D53F8C;--chakra-colors-pink-600:#B83280;--chakra-colors-pink-700:#97266D;--chakra-colors-pink-800:#702459;--chakra-colors-pink-900:#521B41;--chakra-colors-linkedin-50:#E8F4F9;--chakra-colors-linkedin-100:#CFEDFB;--chakra-colors-linkedin-200:#9BDAF3;--chakra-colors-linkedin-300:#68C7EC;--chakra-colors-linkedin-400:#34B3E4;--chakra-colors-linkedin-500:#00A0DC;--chakra-colors-linkedin-600:#008CC9;--chakra-colors-linkedin-700:#0077B5;--chakra-colors-linkedin-800:#005E93;--chakra-colors-linkedin-900:#004471;--chakra-colors-facebook-50:#E8F4F9;--chakra-colors-facebook-100:#D9DEE9;--chakra-colors-facebook-200:#B7C2DA;--chakra-colors-facebook-300:#6482C0;--chakra-colors-facebook-400:#4267B2;--chakra-colors-facebook-500:#385898;--chakra-colors-facebook-600:#314E89;--chakra-colors-facebook-700:#29487D;--chakra-colors-facebook-800:#223B67;--chakra-colors-facebook-900:#1E355B;--chakra-colors-messenger-50:#D0E6FF;--chakra-colors-messenger-100:#B9DAFF;--chakra-colors-messenger-200:#A2CDFF;--chakra-colors-messenger-300:#7AB8FF;--chakra-colors-messenger-400:#2E90FF;--chakra-colors-messenger-500:#0078FF;--chakra-colors-messenger-600:#0063D1;--chakra-colors-messenger-700:#0052AC;--chakra-colors-messenger-800:#003C7E;--chakra-colors-messenger-900:#002C5C;--chakra-colors-whatsapp-50:#dffeec;--chakra-colors-whatsapp-100:#b9f5d0;--chakra-colors-whatsapp-200:#90edb3;--chakra-colors-whatsapp-300:#65e495;--chakra-colors-whatsapp-400:#3cdd78;--chakra-colors-whatsapp-500:#22c35e;--chakra-colors-whatsapp-600:#179848;--chakra-colors-whatsapp-700:#0c6c33;--chakra-colors-whatsapp-800:#01421c;--chakra-colors-whatsapp-900:#001803;--chakra-colors-twitter-50:#E5F4FD;--chakra-colors-twitter-100:#C8E9FB;--chakra-colors-twitter-200:#A8DCFA;--chakra-colors-twitter-300:#83CDF7;--chakra-colors-twitter-400:#57BBF5;--chakra-colors-twitter-500:#1DA1F2;--chakra-colors-twitter-600:#1A94DA;--chakra-colors-twitter-700:#1681BF;--chakra-colors-twitter-800:#136B9E;--chakra-colors-twitter-900:#0D4D71;--chakra-colors-telegram-50:#E3F2F9;--chakra-colors-telegram-100:#C5E4F3;--chakra-colors-telegram-200:#A2D4EC;--chakra-colors-telegram-300:#7AC1E4;--chakra-colors-telegram-400:#47A9DA;--chakra-colors-telegram-500:#0088CC;--chakra-colors-telegram-600:#007AB8;--chakra-colors-telegram-700:#006BA1;--chakra-colors-telegram-800:#005885;--chakra-colors-telegram-900:#003F5E;--chakra-borders-none:0;--chakra-borders-1px:1px solid;--chakra-borders-2px:2px solid;--chakra-borders-4px:4px solid;--chakra-borders-8px:8px solid;--chakra-fonts-heading:-apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--chakra-fonts-body:-apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--chakra-fonts-mono:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--chakra-fontSizes-xs:0.75rem;--chakra-fontSizes-sm:0.875rem;--chakra-fontSizes-md:1rem;--chakra-fontSizes-lg:1.125rem;--chakra-fontSizes-xl:1.25rem;--chakra-fontSizes-2xl:1.5rem;--chakra-fontSizes-3xl:1.875rem;--chakra-fontSizes-4xl:2.25rem;--chakra-fontSizes-5xl:3rem;--chakra-fontSizes-6xl:3.75rem;--chakra-fontSizes-7xl:4.5rem;--chakra-fontSizes-8xl:6rem;--chakra-fontSizes-9xl:8rem;--chakra-fontWeights-hairline:100;--chakra-fontWeights-thin:200;--chakra-fontWeights-light:300;--chakra-fontWeights-normal:400;--chakra-fontWeights-medium:500;--chakra-fontWeights-semibold:600;--chakra-fontWeights-bold:700;--chakra-fontWeights-extrabold:800;--chakra-fontWeights-black:900;--chakra-letterSpacings-tighter:-0.05em;--chakra-letterSpacings-tight:-0.025em;--chakra-letterSpacings-normal:0;--chakra-letterSpacings-wide:0.025em;--chakra-letterSpacings-wider:0.05em;--chakra-letterSpacings-widest:0.1em;--chakra-lineHeights-3:.75rem;--chakra-lineHeights-4:1rem;--chakra-lineHeights-5:1.25rem;--chakra-lineHeights-6:1.5rem;--chakra-lineHeights-7:1.75rem;--chakra-lineHeights-8:2rem;--chakra-lineHeights-9:2.25rem;--chakra-lineHeights-10:2.5rem;--chakra-lineHeights-normal:normal;--chakra-lineHeights-none:1;--chakra-lineHeights-shorter:1.25;--chakra-lineHeights-short:1.375;--chakra-lineHeights-base:1.5;--chakra-lineHeights-tall:1.625;--chakra-lineHeights-taller:2;--chakra-radii-none:0;--chakra-radii-sm:0.125rem;--chakra-radii-base:0.25rem;--chakra-radii-md:0.375rem;--chakra-radii-lg:0.5rem;--chakra-radii-xl:0.75rem;--chakra-radii-2xl:1rem;--chakra-radii-3xl:1.5rem;--chakra-radii-full:9999px;--chakra-space-1:0.25rem;--chakra-space-2:0.5rem;--chakra-space-3:0.75rem;--chakra-space-4:1rem;--chakra-space-5:1.25rem;--chakra-space-6:1.5rem;--chakra-space-7:1.75rem;--chakra-space-8:2rem;--chakra-space-9:2.25rem;--chakra-space-10:2.5rem;--chakra-space-12:3rem;--chakra-space-14:3.5rem;--chakra-space-16:4rem;--chakra-space-20:5rem;--chakra-space-24:6rem;--chakra-space-28:7rem;--chakra-space-32:8rem;--chakra-space-36:9rem;--chakra-space-40:10rem;--chakra-space-44:11rem;--chakra-space-48:12rem;--chakra-space-52:13rem;--chakra-space-56:14rem;--chakra-space-60:15rem;--chakra-space-64:16rem;--chakra-space-72:18rem;--chakra-space-80:20rem;--chakra-space-96:24rem;--chakra-space-px:1px;--chakra-space-0\.5:0.125rem;--chakra-space-1\.5:0.375rem;--chakra-space-2\.5:0.625rem;--chakra-space-3\.5:0.875rem;--chakra-shadows-xs:0 0 0 1px rgba(0, 0, 0, 0.05);--chakra-shadows-sm:0 1px 2px 0 rgba(0, 0, 0, 0.05);--chakra-shadows-base:0 1px 3px 0 rgba(0, 0, 0, 0.1),0 1px 2px 0 rgba(0, 0, 0, 0.06);--chakra-shadows-md:0 4px 6px -1px rgba(0, 0, 0, 0.1),0 2px 4px -1px rgba(0, 0, 0, 0.06);--chakra-shadows-lg:0 10px 15px -3px rgba(0, 0, 0, 0.1),0 4px 6px -2px rgba(0, 0, 0, 0.05);--chakra-shadows-xl:0 20px 25px -5px rgba(0, 0, 0, 0.1),0 10px 10px -5px rgba(0, 0, 0, 0.04);--chakra-shadows-2xl:0 25px 50px -12px rgba(0, 0, 0, 0.25);--chakra-shadows-outline:0 0 0 3px rgba(66, 153, 225, 0.6);--chakra-shadows-inner:inset 0 2px 4px 0 rgba(0,0,0,0.06);--chakra-shadows-none:none;--chakra-shadows-dark-lg:rgba(0, 0, 0, 0.1) 0px 0px 0px 1px,rgba(0, 0, 0, 0.2) 0px 5px 10px,rgba(0, 0, 0, 0.4) 0px 15px 40px;--chakra-sizes-1:0.25rem;--chakra-sizes-2:0.5rem;--chakra-sizes-3:0.75rem;--chakra-sizes-4:1rem;--chakra-sizes-5:1.25rem;--chakra-sizes-6:1.5rem;--chakra-sizes-7:1.75rem;--chakra-sizes-8:2rem;--chakra-sizes-9:2.25rem;--chakra-sizes-10:2.5rem;--chakra-sizes-12:3rem;--chakra-sizes-14:3.5rem;--chakra-sizes-16:4rem;--chakra-sizes-20:5rem;--chakra-sizes-24:6rem;--chakra-sizes-28:7rem;--chakra-sizes-32:8rem;--chakra-sizes-36:9rem;--chakra-sizes-40:10rem;--chakra-sizes-44:11rem;--chakra-sizes-48:12rem;--chakra-sizes-52:13rem;--chakra-sizes-56:14rem;--chakra-sizes-60:15rem;--chakra-sizes-64:16rem;--chakra-sizes-72:18rem;--chakra-sizes-80:20rem;--chakra-sizes-96:24rem;--chakra-sizes-px:1px;--chakra-sizes-0\.5:0.125rem;--chakra-sizes-1\.5:0.375rem;--chakra-sizes-2\.5:0.625rem;--chakra-sizes-3\.5:0.875rem;--chakra-sizes-max:max-content;--chakra-sizes-min:min-content;--chakra-sizes-full:100%;--chakra-sizes-3xs:14rem;--chakra-sizes-2xs:16rem;--chakra-sizes-xs:20rem;--chakra-sizes-sm:24rem;--chakra-sizes-md:28rem;--chakra-sizes-lg:32rem;--chakra-sizes-xl:36rem;--chakra-sizes-2xl:42rem;--chakra-sizes-3xl:48rem;--chakra-sizes-4xl:56rem;--chakra-sizes-5xl:64rem;--chakra-sizes-6xl:72rem;--chakra-sizes-7xl:80rem;--chakra-sizes-8xl:90rem;--chakra-sizes-container-sm:640px;--chakra-sizes-container-md:768px;--chakra-sizes-container-lg:1024px;--chakra-sizes-container-xl:1280px;--chakra-zIndices-hide:-1;--chakra-zIndices-auto:auto;--chakra-zIndices-base:0;--chakra-zIndices-docked:10;--chakra-zIndices-dropdown:1000;--chakra-zIndices-sticky:1100;--chakra-zIndices-banner:1200;--chakra-zIndices-overlay:1300;--chakra-zIndices-modal:1400;--chakra-zIndices-popover:1500;--chakra-zIndices-skipLink:1600;--chakra-zIndices-toast:1700;--chakra-zIndices-tooltip:1800;--chakra-transition-property-common:background-color,border-color,color,fill,stroke,opacity,box-shadow,transform;--chakra-transition-property-colors:background-color,border-color,color,fill,stroke;--chakra-transition-property-dimensions:width,height;--chakra-transition-property-position:left,right,top,bottom;--chakra-transition-property-background:background-color,background-image,background-position;--chakra-transition-easing-ease-in:cubic-bezier(0.4, 0, 1, 1);--chakra-transition-easing-ease-out:cubic-bezier(0, 0, 0.2, 1);--chakra-transition-easing-ease-in-out:cubic-bezier(0.4, 0, 0.2, 1);--chakra-transition-duration-ultra-fast:50ms;--chakra-transition-duration-faster:100ms;--chakra-transition-duration-fast:150ms;--chakra-transition-duration-normal:200ms;--chakra-transition-duration-slow:300ms;--chakra-transition-duration-slower:400ms;--chakra-transition-duration-ultra-slow:500ms;--chakra-blur-none:0;--chakra-blur-sm:4px;--chakra-blur-base:8px;--chakra-blur-md:12px;--chakra-blur-lg:16px;--chakra-blur-xl:24px;--chakra-blur-2xl:40px;--chakra-blur-3xl:64px;}</style><style data-emotion="css-global 1syi0wy">html{line-height:1.5;-webkit-text-size-adjust:100%;font-family:system-ui,sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;touch-action:manipulation;}body{position:relative;min-height:100%;font-feature-settings:'kern';}*,*::before,*::after{border-width:0;border-style:solid;box-sizing:border-box;}main{display:block;}hr{border-top-width:1px;box-sizing:content-box;height:0;overflow:visible;}pre,code,kbd,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,monospace;font-size:1em;}a{background-color:transparent;color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit;}abbr[title]{border-bottom:none;-webkit-text-decoration:underline;text-decoration:underline;-webkit-text-decoration:underline dotted;-webkit-text-decoration:underline dotted;text-decoration:underline dotted;}b,strong{font-weight:bold;}small{font-size:80%;}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline;}sub{bottom:-0.25em;}sup{top:-0.5em;}img{border-style:none;}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0;}button,input{overflow:visible;}button,select{text-transform:none;}button::-moz-focus-inner,[type="button"]::-moz-focus-inner,[type="reset"]::-moz-focus-inner,[type="submit"]::-moz-focus-inner{border-style:none;padding:0;}fieldset{padding:0.35em 0.75em 0.625em;}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal;}progress{vertical-align:baseline;}textarea{overflow:auto;}[type="checkbox"],[type="radio"]{box-sizing:border-box;padding:0;}[type="number"]::-webkit-inner-spin-button,[type="number"]::-webkit-outer-spin-button{-webkit-appearance:none!important;}input[type="number"]{-moz-appearance:textfield;}[type="search"]{-webkit-appearance:textfield;outline-offset:-2px;}[type="search"]::-webkit-search-decoration{-webkit-appearance:none!important;}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit;}details{display:block;}summary{display:-webkit-box;display:-webkit-list-item;display:-ms-list-itembox;display:list-item;}template{display:none;}[hidden]{display:none!important;}body,blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0;}button{background:transparent;padding:0;}fieldset{margin:0;padding:0;}ol,ul{margin:0;padding:0;}textarea{resize:vertical;}button,[role="button"]{cursor:pointer;}button::-moz-focus-inner{border:0!important;}table{border-collapse:collapse;}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit;}button,input,optgroup,select,textarea{padding:0;line-height:inherit;color:inherit;}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle;}img,video{max-width:100%;height:auto;}[data-js-focus-visible] :focus:not([data-focus-visible-added]){outline:none;box-shadow:none;}select::-ms-expand{display:none;}</style><style data-emotion="css-global 1baqkrf">body{font-family:var(--chakra-fonts-body);color:var(--chakra-colors-gray-800);background:var(--chakra-colors-white);transition-property:background-color;transition-duration:var(--chakra-transition-duration-normal);line-height:var(--chakra-lineHeights-base);}*::-webkit-input-placeholder{color:var(--chakra-colors-gray-400);}*::-moz-placeholder{color:var(--chakra-colors-gray-400);}*:-ms-input-placeholder{color:var(--chakra-colors-gray-400);}*::placeholder{color:var(--chakra-colors-gray-400);}*,*::before,::after{border-color:var(--chakra-colors-gray-200);word-wrap:break-word;}</style><div><p class="chakra-text mb-4 css-0">Nota bene: this instalment in the Ports and Adapters with Command Handlers series is
code-heavy, and isn&#x27;t going to make much sense unless you&#x27;ve read the previous parts:</p><ul><li>Introducing Command Handler <!-- -->[https://io.made.com/blog/introducing-command-handler/]</li><li>Repositories and Units of Work
<!-- -->[https://io.made.com/blog/repository-and-unit-of-work-pattern-in-python/]</li><li>Commands and Queries, Handlers and Views
<!-- -->[https://io.made.com/blog/commands-and-queries-handlers-and-views/]</li></ul><p class="chakra-text mb-4 css-0">Okay, so we have a basic skeleton for an application and we can add new issues into the
database, then fetch them from a Flask API. So far, though, we don&#x27;t have any domain
logic at all. All we have is a whole bunch of complicated crap where we could just have
a tiny Django app. Let&#x27;s work through some more use-cases and start to flesh things out.</p><p class="chakra-text mb-4 css-0">Back to our domain expert:</p><p class="chakra-text mb-4 css-0">So when we&#x27;ve added a reported issue to the issue log, what happens next?</p><p class="chakra-text mb-4 css-0">Well we need to triage the problem and decide how urgent it is. Then we might assign it
to a particular engineer, or we might leave it on the queue to be picked up by anyone.</p><p class="chakra-text mb-4 css-0">Wait, the queue? I thought you had an issue log, are they the same thing, or is there a
difference?</p><p class="chakra-text mb-4 css-0">Oh, yes. The issue log is just a record of all the issues we have received, but we work
from the queue.</p><p class="chakra-text mb-4 css-0">I see, and how do things get into the queue?</p><p class="chakra-text mb-4 css-0">We triage the new items in the issue log to decide how urgent they are, and what
categories they should be in. When we know how to categorise them, and how urgent they
are, we treat the issues as a queue, and work through them in priority order.</p><p class="chakra-text mb-4 css-0">This is because users always set things to &quot;Extremely urgent&quot;?</p><p class="chakra-text mb-4 css-0">Yeah, it&#x27;s just easier for us to triage the issues ourselves.</p><p class="chakra-text mb-4 css-0">And what does that actually mean, like, do you just read the ticket and say &quot;oh, this is
5 important, and it&#x27;s in the broken mouse category&quot;?</p><p class="chakra-text mb-4 css-0">Mmmm... more or less, sometimes we need to ask more questions from the user so we&#x27;ll
email them, or call them. Most things are first-come, first-served, but occasionally
someone needs a fix before they can go to a meeting or something.</p><p class="chakra-text mb-4 css-0">So you email the user to get more information, or you call them up, and then you use
that information to assess the priority of the issue - sorry triage the issue, and work
out what category it should go in... what do the categories achieve? Why categorise?</p><p class="chakra-text mb-4 css-0">Partly for reporting, so we can see what stuff is taking up the most time, or if there
are clusters of similar problems on a particular batch of laptops for example. Mostly
because different engineers have different skills, like if you have a problem with the
Active Directory domain, then you should send that to Barry, or if it&#x27;s an Exchange
problem, then George can sort it out, and Mike has the equipment log so he can give you
a temporary laptop and so on, and so on.</p><p class="chakra-text mb-4 css-0">Okay, and where do I find this &quot;queue&quot;?</p><p class="chakra-text mb-4 css-0">Your customer grins and gestures at the wall where a large whiteboard is covered in
post-its and stickers of different colours.</p><p class="chakra-text mb-4 css-0">Mapping our requirements to our domain How can we map these requirements back to our
system? Looking back over our notes with the domain expert, there&#x27;s a few obvious verbs
that we should use to model our use cases. We can triage an issue, which means we
prioritise and categorise it; we can assign a triaged issue to an engineer, or an
engineer can pick up an unassigned issue. There&#x27;s also a whole piece about asking
questions, which we might do synchronously by making a phone call and filling out some
more details, or asynchronously by sending an email. The Queue, with all of its stickers
and sigils and swimlanes looks too complicated to handle today, so we&#x27;ll dig deeper into
that separately.</p><p class="chakra-text mb-4 css-0">Let&#x27;s quickly flesh out the triage use cases. We&#x27;ll start by updating the existing unit
test for reporting an issue:</p><p class="chakra-text mb-4 css-0">class When_reporting_an_issue:</p><pre><code>def given_an_empty_unit_of_work(self):
    self.uow = FakeUnitOfWork()

def because_we_report_a_new_issue(self):
    handler = ReportIssueHandler(self.uow)
    cmd = ReportIssueCommand(id, name, email, desc)
    handler.handle(cmd)

@property
def issue(self):
    return self.uow.issues[0]

def it_should_be_awaiting_triage(self):
    expect(self.issue.state).to(equal(IssueState.AwaitingTriage))
</code></pre><p class="chakra-text mb-4 css-0">We&#x27;re introducing a new concept - Issues now have a state, and a newly reported issue
begins in the AwaitingTriage state. We can quickly add a command and handler that allows
us to triage an issue.</p><p class="chakra-text mb-4 css-0">class TriageIssueHandler:</p><pre><code>def __init__(self, uowm: UnitOfWorkManager):
    self.uowm = uowm

def handle(self, cmd):
    with self.uowm.start() as uow:
        issue = uow.issues.get(cmd.issue_id)
        issue.triage(cmd.priority, cmd.category)
        uow.commit()
</code></pre><p class="chakra-text mb-4 css-0">Triaging an issue, for now, is a matter of selecting a category and priority. We&#x27;ll use
a free string for category, and an enumeration for Priority. Once an issue is triaged,
it enters the AwaitingAssignment state. At some point we&#x27;ll need to add some view
builders to list issues that are waiting for triage or assignment, but for now let&#x27;s
quickly add a handler so that an engineer can Pick an issue from the queue.</p><p class="chakra-text mb-4 css-0">class PickIssueHandler:</p><pre><code>def __init__(self, uowm: UnitOfWorkManager):
    self.uowm = uowm

def handle(self, cmd):
    with self.uowm.start() as uow:
        issue = uow.issues.get(cmd.issue_id)
        issue.assign_to(cmd.picked_by)
        uow.commit()
</code></pre><p class="chakra-text mb-4 css-0">At this point, the handlers are becoming a little boring. As I said way back in the
first part <!-- -->[https://io.made.com/blog/introducing-command-handler/]<!-- -->, commands handlers
are supposed to be boring glue-code, and every command handler has the same basic
structure:</p><ol><li>Fetch current state.</li><li>Mutate the state by calling a method on our domain model.</li><li>Persist the new state.</li><li>Notify other parts of the system that our state has changed.</li></ol><p class="chakra-text mb-4 css-0">So far, though, we&#x27;ve only seen steps 1, 2, and 3. Let&#x27;s introduce a new requirement.</p><p class="chakra-text mb-4 css-0">When an issue is assigned to an engineer, can we send them an email to let them know?</p><p class="chakra-text mb-4 css-0">A brief discourse on SRP Let&#x27;s try and implement this new requirement. Here&#x27;s a first
attempt:</p><p class="chakra-text mb-4 css-0">class AssignIssueHandler:</p><pre><code>def __init__(self,
           uowm: UnitOfWorkManager,
           email_builder: EmailBuilder,
           email_sender: EmailSender):
    self.uowm = uowm
    self.email_builder = email_builder
    self.email_sender = email_sender

def handle(self, cmd):
    # Assign Issue
    with self.uowm.start() as uow:
        issue = uow.issues.get(cmd.issue_id)
        issue.assign_to(
            cmd.assigned_to,
            assigned_by=cmd.assigned_by
        )
        uow.commit()

    # Send Email
    email = self.email_builder.build(
            cmd.assigned_to,
            cmd.assigned_by,
            issue.problem_description)
    self.email_sender.send(email)
</code></pre><p class="chakra-text mb-4 css-0">Something here feels wrong, right? Our command-handler now has two very distinct
responsibilities. Back at the beginning of this series we said we would stick with three
principles:</p><ol><li>We will always define where our use-cases begin and end.</li><li>We will depend on abstractions, and not on concrete implementations.</li><li>We will treat glue code as distinct from business logic, and put it in an
appropriate place.</li></ol><p class="chakra-text mb-4 css-0">The latter two are being maintained here, but the first principle feels a little more
strained. At the very least we&#x27;re violating the Single Responsibility Principle
<!-- -->[https://en.wikipedia.org/wiki/Single_responsibility_principle]<!-- -->; my rule of thumb for
the SRP is &quot;describe the behaviour of your class. If you use the word &#x27;and&#x27; or &#x27;then&#x27;
you may be breaking the SRP&quot;. What does this class do? It assigns an issue to an
engineer, AND THEN sends them an email. That&#x27;s enough to get my refactoring senses
tingling, but there&#x27;s another, less theoretical, reason to split this method up, and
it&#x27;s to do with error handling.</p><p class="chakra-text mb-4 css-0">If I click a button marked &quot;Assign to engineer&quot;, and I can&#x27;t assign the issue to that
engineer, then I expect an error. The system can&#x27;t execute the command I&#x27;ve given to it,
so I should retry, or choose a different engineer.</p><p class="chakra-text mb-4 css-0">If I click a button marked &quot;Assign to engineer&quot;, and the system succeeds, but then can&#x27;t
send a notification email, do I care? What action should I take in response? Should I
assign the issue again? Should I assign it to someone else? What state will the system
be in if I do?</p><p class="chakra-text mb-4 css-0">Looking at the problem in this way, it&#x27;s clear that &quot;assigning the issue&quot; is the real
boundary of our use case, and we should either do that successfully, or fail completely.
&quot;Send the email&quot; is a secondary side effect. If that part fails I don&#x27;t want to see an
error - let the sysadmins clear it up later.</p><p class="chakra-text mb-4 css-0">What if we split out the notification to another class?</p><p class="chakra-text mb-4 css-0">class AssignIssueHandler:</p><pre><code>def __init__(self, uowm: UnitOfWorkManager):
    self.uowm = uowm

def handle(self, cmd):
    with self.uowm.start() as uow:
        issue = uow.issues.get(cmd.issue_id)
        issue.assign_to(
            cmd.assignee_address,
            assigned_by=cmd.assigner_address
        )
        uow.commit()
</code></pre><p class="chakra-text mb-4 css-0">class SendAssignmentEmailHandler def <strong>init</strong>(self, uowm: UnitOfWorkManager,
email_builder: EmailBuilder, email_sender: EmailSender): self.uowm = uowm
self.email_builder = email_builder self.email_sender = email_sender</p><pre><code>def handle(self, cmd):
    with self.uowm.start() as uow:
        issue = uow.issues.get(cmd.issue_id)

        email = self.email_builder.build(
            cmd.assignee_address,
            cmd.assigner_address,
            issue.problem_description)
        self.email_sender.send(email)
</code></pre><p class="chakra-text mb-4 css-0">We don&#x27;t really need a unit of work here, because we&#x27;re not making any persistent
changes to the Issue state, so what if we use a view builder instead?</p><p class="chakra-text mb-4 css-0">class SendAssignmentEmailHandler def <strong>init</strong>(self, view: IssueViewBuilder,
email_builder: EmailBuilder, email_sender: EmailSender): self.view = view
self.email_builder = email_builder self.email_sender = email_sender</p><pre><code>def handle(self, cmd):
    issue = self.view.fetch(cmd.issue_id)

    email = self.email_builder.build(
        cmd.assignee_address,
        cmd.assigner_address,
        issue[&#x27;problem_description&#x27;])
    self.email_sender.send(email)
</code></pre><p class="chakra-text mb-4 css-0">That seems better, but how should we invoke our new handler? Building a new command and
handler from inside our AssignIssueHandler also sounds like a violation of SRP. Worse
still, if we start calling handlers from handlers, we&#x27;ll end up with our use cases
coupled together again - and that&#x27;s definitely a violation of Principle #1.</p><p class="chakra-text mb-4 css-0">What we need is a way to signal between handlers - a way of saying &quot;I did my job, can
you go do yours?&quot;</p><p class="chakra-text mb-4 css-0">All Aboard the Message Bus In this kind of system, we use Domain Events
<!-- -->[http://verraes.net/2014/11/domain-events/]<!-- --> to fill that need. Events are closely
related to Commands, in that both commands and events are types of message
<!-- -->[http://www.enterpriseintegrationpatterns.com/patterns/messaging/Message.html]</p><ul><li>named chunks of data sent between entities. Commands and events differ only in their
intent:</li></ul><ol><li>Commands are named with the imperative tense (Do this thing), events are named in
the past tense (Thing was done).</li><li>Commands must be handled by exactly one handler, events can be handled by 0 to N
handlers.</li><li>If an error occurs when processing a command, the entire request should fail. If an
error occurs while processing an event, we should fail gracefully.</li></ol><p class="chakra-text mb-4 css-0">We will often use domain events to signal that a command has been processed and to do
any additional book-keeping. When should we use a domain event? Going back to our
principle #1, we should use events to trigger workflows that fall outside of our
immediate use-case boundary. In this instance, our use-case boundary is &quot;assign the
issue&quot;, and there is a second requirement &quot;notify the assignee&quot; that should happen as a
secondary result. Notifications, to humans or other systems, are one of the most common
reasons to trigger events in this way, but they might also be used to clear a cache, or
regenerate a view model, or execute some logic to make the system eventually consistent.</p><p class="chakra-text mb-4 css-0">Armed with this knowledge, we know what to do - we need to raise a domain event when we
assign an issue to an engineer. We don&#x27;t want to know about the subscribers to our
event, though, or we&#x27;ll remain coupled; what we need is a mediator, a piece of
infrastructure that can route messages to the correct places. What we need is a message
bus. A message bus is a simple piece of middleware that&#x27;s responsible for getting
messages to the right listeners. In our application we have two kinds of message,
commands and events. These two types of message are in some sense symmetrical, so we&#x27;ll
use a single message bus for both.</p><p class="chakra-text mb-4 css-0">How do we start off writing a message bus? Well, it needs to look up subscribers based
on the name of an event. That sounds like a dict to me:</p><p class="chakra-text mb-4 css-0">class MessageBus:</p><pre><code>def __init__(self):
    &quot;&quot;&quot;Our message bus is just a mapping from message type
       to a list of handlers&quot;&quot;&quot;
    self.subscribers = defaultdict(list)

def handle(self, msg):
    &quot;&quot;&quot;The handle method invokes each handler in turn
       with our event&quot;&quot;&quot;
    msg_name = type(msg).__name__
    subscribers = self.subscribers[msg_name]
    for subscriber in subscribers:
        subscriber.handle(cmd)

def subscribe_to(self, msg, handler):
    &quot;&quot;&quot;Subscribe sets up a new mapping, we make sure not
       to allow more than one handler for a command&quot;&quot;&quot;
    subscribers = [msg.__name__]
    if msg.is_cmd and len(subscribers) &gt; 0:
       raise CommandAlreadySubscribedException(msg.__name__)
    subscribers.append(handler)
</code></pre><style data-emotion="css 1i61012">.css-1i61012{font-family:var(--chakra-fonts-heading);font-weight:var(--chakra-fontWeights-bold);font-size:var(--chakra-fontSizes-6xl);line-height:1;}@media screen and (min-width: 48em){.css-1i61012{font-size:var(--chakra-fontSizes-7xl);}}</style><h1 class="chakra-heading css-1i61012">Example usage</h1><p class="chakra-text mb-4 css-0">bus = MessageBus() bus.subscribe_to(ReportIssueCommand,
ReportIssueHandler(db.unit_of_work_manager)) bus.handle(cmd)</p><p class="chakra-text mb-4 css-0">Here we have a bare-bones implementation of a message bus. It doesn&#x27;t do anything fancy,
but it will do the job for now. In a production system, the message bus is an excellent
place to put cross-cutting concerns; for example, we might want to validate our commands
before passing them to handlers, or we may want to perform some basic logging, or
performance monitoring. I want to talk more about that in the next part, when we&#x27;ll
tackle the controversial subject of dependency injection and Inversion of Control
containers.</p><p class="chakra-text mb-4 css-0">For now, let&#x27;s look at how to hook this up. Firstly, we want to use it from our API
handlers.</p><p class="chakra-text mb-4 css-0">@api.route(&#x27;/issues&#x27;, methods=<!-- -->[&#x27;POST&#x27;]<!-- -->) def create_issue(self): issue_id = uuid.uuid4()
cmd = ReportIssueCommand(issue_id=issue_id, <!-- -->*<!-- -->*<!-- -->request.get_json()) bus.handle(cmd)
return &quot;&quot;, 201, {&quot;Location&quot;: &quot;/issues/&quot; + str(issue_id) }</p><p class="chakra-text mb-4 css-0">Not much has changed here - we&#x27;re still building our command in the Flask adapter, but
now we&#x27;re passing it into a bus instead of directly constructing a handler for
ourselves. What about when we need to raise an event? We&#x27;ve got several options for
doing this. Usually I raise events from my command handlers, like this:</p><p class="chakra-text mb-4 css-0">class AssignIssueHandler:</p><pre><code>def handle(self, cmd):
    with self.uowm.start() as uow:
        issue = uow.issues.get(cmd.id)
        issue.assign_to(cmd.assigned_to, cmd.assigned_by)
        uow.commit()

    # This is step 4: notify other parts of the system
    self.bus.raise(IssueAssignedToEngineer(
        cmd.issue_id,
        cmd.assigned_to,
        cmd.assigned_by))
</code></pre><p class="chakra-text mb-4 css-0">I usually think of this event-raising as a kind of glue - it&#x27;s orchestration code.
Raising events from your handlers this way makes the flow of messages explicit - you
don&#x27;t have to look anywhere else in the system to understand which events will flow from
a command. It&#x27;s also very simple in terms of plumbing. The counter argument is that this
feels like we&#x27;re violating SRP in exactly the same way as before - we&#x27;re sending a
notification about our workflow. Is this really any different to sending the email
directly from the handler? Another option is to send events directly from our model
objects, and treat them as part our domain model proper.</p><p class="chakra-text mb-4 css-0">class Issue:</p><pre><code>def assign_to(self, assigned_to, assigned_by):
    self.assigned_to = assigned_to
    self.assigned_by = assigned_by

    # Add our new event to a list
    self.events.add(IssueAssignedToEngineer(self.id, self.assigned_to, self.assigned_by))
</code></pre><p class="chakra-text mb-4 css-0">There&#x27;s a couple of benefits of doing this: firstly, it keeps our command handler
simpler, but secondly it pushes the logic for deciding when to send an event into the
model. For example, maybe we don&#x27;t always need to raise the event.</p><p class="chakra-text mb-4 css-0">class Issue:</p><pre><code>def assign_to(self, assigned_to, assigned_by):
    self.assigned_to = assigned_to
    self.assigned_by = assigned_by

    # don&#x27;t raise the event if I picked the issue myself
    if self.assigned_to != self.assigned_by:
        self.events.add(IssueAssignedToEngineer(self.id, self.assigned_to, self.assigned_by))
</code></pre><p class="chakra-text mb-4 css-0">Now we&#x27;ll only raise our event if the issue was assigned by another engineer. Cases like
this are more like business logic than glue code, so today I&#x27;m choosing to put them in
my domain model. Updating our unit tests is trivial, because we&#x27;re just exposing the
events as a list on our model objects:</p><p class="chakra-text mb-4 css-0">class When_assigning_an_issue:</p><pre><code>issue_id = uuid.uuid4()
assigned_to = &#x27;ashley@example.org&#x27;
assigned_by = &#x27;laura@example.org&#x27;

def given_a_new_issue(self):
    self.issue = Issue(self.issue_id, &#x27;reporter@example.org&#x27;, &#x27;how do I even?&#x27;)

def because_we_assign_the_issue(self):
    self.issue.assign(self.assigned_to, self.assigned_by)

def we_should_raise_issue_assigned(self):
    expect(self.issue).to(have_raised(
        IssueAssignedToEngineer(self.issue_id,
                                self.assigned_to,
                                self.assigned_by)))
</code></pre><p class="chakra-text mb-4 css-0">The have_raised function is a custom matcher I wrote that checks the events attribute of
our object to see if we raised the correct event. It&#x27;s easy to test for the presence of
events, because they&#x27;re namedtuples, and have value equality.</p><p class="chakra-text mb-4 css-0">All that remains is to get the events off our model objects and into our message bus.
What we need is a way to detect that we&#x27;ve finished one use-case and are ready to flush
our changes. Fortunately, we have a name for this already - it&#x27;s a unit of work. In this
system I&#x27;m using SQLAlchemy&#x27;s event hooks
<!-- -->[http://docs.sqlalchemy.org/en/latest/orm/session_events.html]<!-- --> to work out which objects
have changed, and queue up their events. When the unit of work exits, we raise the
events.</p><p class="chakra-text mb-4 css-0">class SqlAlchemyUnitOfWork(UnitOfWork):</p><pre><code>def __init__(self, sessionfactory, bus):
    self.sessionfactory = sessionfactory
    self.bus = bus
    # We want to listen to flush events so that we can get events
    # from our model objects
    event.listen(self.sessionfactory, &quot;after_flush&quot;, self.gather_events)

def __enter__(self):
    self.session = self.sessionfactory()
    # When we first start a unit of work, create a list of events
    self.flushed_events = []
    return self

def commit(self):
    self.session.flush()
    self.session.commit()

def rollback(self):
    self.session.rollback()
    # If we roll back our changes we should drop all the events
    self.events = []

def gather_events(self, session, ctx):
    # When we flush changes, add all the events from our new and
    # updated entities into the events list
    flushed_objects = ([e for e in session.new]
                    + [e for e in session.dirty])
    for e in flushed_objects:
        self.flushed_events += e.events

def publish_events(self):
    # When the unit of work completes
    # raise any events that are in the list
    for e in self.flushed_events:
        self.bus.handle(e)

def __exit__(self, type, value, traceback):
    self.session.close()
    self.publish_events()
</code></pre><p class="chakra-text mb-4 css-0">Okay, we&#x27;ve covered a lot of ground here. We&#x27;ve discussed why you might want to use
domain events, how a message bus actually works in practice, and how we can get events
out of our domain and into our subscribers. The newest code sample
<!-- -->[https://github.com/bobthemighty/blog-code-samples/tree/master/ports-and-adapters/04]<!-- -->
demonstrates these ideas, please do check it out, run it, open pull requests, open
Github issues etc.</p><p class="chakra-text mb-4 css-0">Some people get nervous about the design of the message bus, or the unit of work, but
this is just infrastructure - it can be ugly, so long as it works. We&#x27;re unlikely to
ever change this code after the first few user-stories. It&#x27;s okay to have some crufty
code here, so long as it&#x27;s in our glue layers, safely away from our domain model.
Remember, we&#x27;re doing all of this so that our domain model can stay pure and be flexible
when we need to refactor. Not all layers of the system are equal, glue code is just
glue.</p><p class="chakra-text mb-4 css-0">Next time I want to talk about Dependency Injection, why it&#x27;s great, and why it&#x27;s
nothing to be afraid of.</p></div><span></span></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"var h=Object.defineProperty,m=Object.defineProperties;var c=Object.getOwnPropertyDescriptors;var o=Object.getOwnPropertySymbols;var n=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable;var l=(e,s,a)=\u003es in e?h(e,s,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[s]=a,t=(e,s)=\u003e{for(var a in s||(s={}))n.call(s,a)\u0026\u0026l(e,a,s[a]);if(o)for(var a of o(s))r.call(s,a)\u0026\u0026l(e,a,s[a]);return e},d=(e,s)=\u003em(e,c(s));var u=(e,s)=\u003e{var a={};for(var i in e)n.call(e,i)\u0026\u0026s.indexOf(i)\u003c0\u0026\u0026(a[i]=e[i]);if(e!=null\u0026\u0026o)for(var i of o(e))s.indexOf(i)\u003c0\u0026\u0026r.call(e,i)\u0026\u0026(a[i]=e[i]);return a};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(a){var i=a,{components:e}=i,s=u(i,[\"components\"]);return mdx(MDXLayout,d(t(t({},layoutProps),s),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,`Nota bene: this instalment in the Ports and Adapters with Command Handlers series is\ncode-heavy, and isn't going to make much sense unless you've read the previous parts:`),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Introducing Command Handler \",\"[https://io.made.com/blog/introducing-command-handler/]\"),mdx(\"li\",{parentName:\"ul\"},`Repositories and Units of Work\n`,\"[https://io.made.com/blog/repository-and-unit-of-work-pattern-in-python/]\"),mdx(\"li\",{parentName:\"ul\"},`Commands and Queries, Handlers and Views\n`,\"[https://io.made.com/blog/commands-and-queries-handlers-and-views/]\")),mdx(\"p\",null,`Okay, so we have a basic skeleton for an application and we can add new issues into the\ndatabase, then fetch them from a Flask API. So far, though, we don't have any domain\nlogic at all. All we have is a whole bunch of complicated crap where we could just have\na tiny Django app. Let's work through some more use-cases and start to flesh things out.`),mdx(\"p\",null,\"Back to our domain expert:\"),mdx(\"p\",null,\"So when we've added a reported issue to the issue log, what happens next?\"),mdx(\"p\",null,`Well we need to triage the problem and decide how urgent it is. Then we might assign it\nto a particular engineer, or we might leave it on the queue to be picked up by anyone.`),mdx(\"p\",null,`Wait, the queue? I thought you had an issue log, are they the same thing, or is there a\ndifference?`),mdx(\"p\",null,`Oh, yes. The issue log is just a record of all the issues we have received, but we work\nfrom the queue.`),mdx(\"p\",null,\"I see, and how do things get into the queue?\"),mdx(\"p\",null,`We triage the new items in the issue log to decide how urgent they are, and what\ncategories they should be in. When we know how to categorise them, and how urgent they\nare, we treat the issues as a queue, and work through them in priority order.`),mdx(\"p\",null,'This is because users always set things to \"Extremely urgent\"?'),mdx(\"p\",null,\"Yeah, it's just easier for us to triage the issues ourselves.\"),mdx(\"p\",null,`And what does that actually mean, like, do you just read the ticket and say \"oh, this is\n5 important, and it's in the broken mouse category\"?`),mdx(\"p\",null,`Mmmm... more or less, sometimes we need to ask more questions from the user so we'll\nemail them, or call them. Most things are first-come, first-served, but occasionally\nsomeone needs a fix before they can go to a meeting or something.`),mdx(\"p\",null,`So you email the user to get more information, or you call them up, and then you use\nthat information to assess the priority of the issue - sorry triage the issue, and work\nout what category it should go in... what do the categories achieve? Why categorise?`),mdx(\"p\",null,`Partly for reporting, so we can see what stuff is taking up the most time, or if there\nare clusters of similar problems on a particular batch of laptops for example. Mostly\nbecause different engineers have different skills, like if you have a problem with the\nActive Directory domain, then you should send that to Barry, or if it's an Exchange\nproblem, then George can sort it out, and Mike has the equipment log so he can give you\na temporary laptop and so on, and so on.`),mdx(\"p\",null,'Okay, and where do I find this \"queue\"?'),mdx(\"p\",null,`Your customer grins and gestures at the wall where a large whiteboard is covered in\npost-its and stickers of different colours.`),mdx(\"p\",null,`Mapping our requirements to our domain How can we map these requirements back to our\nsystem? Looking back over our notes with the domain expert, there's a few obvious verbs\nthat we should use to model our use cases. We can triage an issue, which means we\nprioritise and categorise it; we can assign a triaged issue to an engineer, or an\nengineer can pick up an unassigned issue. There's also a whole piece about asking\nquestions, which we might do synchronously by making a phone call and filling out some\nmore details, or asynchronously by sending an email. The Queue, with all of its stickers\nand sigils and swimlanes looks too complicated to handle today, so we'll dig deeper into\nthat separately.`),mdx(\"p\",null,`Let's quickly flesh out the triage use cases. We'll start by updating the existing unit\ntest for reporting an issue:`),mdx(\"p\",null,\"class When_reporting_an_issue:\"),mdx(\"pre\",null,mdx(\"code\",t({parentName:\"pre\"},{}),`def given_an_empty_unit_of_work(self):\n    self.uow = FakeUnitOfWork()\n\ndef because_we_report_a_new_issue(self):\n    handler = ReportIssueHandler(self.uow)\n    cmd = ReportIssueCommand(id, name, email, desc)\n    handler.handle(cmd)\n\n@property\ndef issue(self):\n    return self.uow.issues[0]\n\ndef it_should_be_awaiting_triage(self):\n    expect(self.issue.state).to(equal(IssueState.AwaitingTriage))\n`)),mdx(\"p\",null,`We're introducing a new concept - Issues now have a state, and a newly reported issue\nbegins in the AwaitingTriage state. We can quickly add a command and handler that allows\nus to triage an issue.`),mdx(\"p\",null,\"class TriageIssueHandler:\"),mdx(\"pre\",null,mdx(\"code\",t({parentName:\"pre\"},{}),`def __init__(self, uowm: UnitOfWorkManager):\n    self.uowm = uowm\n\ndef handle(self, cmd):\n    with self.uowm.start() as uow:\n        issue = uow.issues.get(cmd.issue_id)\n        issue.triage(cmd.priority, cmd.category)\n        uow.commit()\n`)),mdx(\"p\",null,`Triaging an issue, for now, is a matter of selecting a category and priority. We'll use\na free string for category, and an enumeration for Priority. Once an issue is triaged,\nit enters the AwaitingAssignment state. At some point we'll need to add some view\nbuilders to list issues that are waiting for triage or assignment, but for now let's\nquickly add a handler so that an engineer can Pick an issue from the queue.`),mdx(\"p\",null,\"class PickIssueHandler:\"),mdx(\"pre\",null,mdx(\"code\",t({parentName:\"pre\"},{}),`def __init__(self, uowm: UnitOfWorkManager):\n    self.uowm = uowm\n\ndef handle(self, cmd):\n    with self.uowm.start() as uow:\n        issue = uow.issues.get(cmd.issue_id)\n        issue.assign_to(cmd.picked_by)\n        uow.commit()\n`)),mdx(\"p\",null,`At this point, the handlers are becoming a little boring. As I said way back in the\nfirst part `,\"[https://io.made.com/blog/introducing-command-handler/]\",`, commands handlers\nare supposed to be boring glue-code, and every command handler has the same basic\nstructure:`),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},\"Fetch current state.\"),mdx(\"li\",{parentName:\"ol\"},\"Mutate the state by calling a method on our domain model.\"),mdx(\"li\",{parentName:\"ol\"},\"Persist the new state.\"),mdx(\"li\",{parentName:\"ol\"},\"Notify other parts of the system that our state has changed.\")),mdx(\"p\",null,\"So far, though, we've only seen steps 1, 2, and 3. Let's introduce a new requirement.\"),mdx(\"p\",null,\"When an issue is assigned to an engineer, can we send them an email to let them know?\"),mdx(\"p\",null,`A brief discourse on SRP Let's try and implement this new requirement. Here's a first\nattempt:`),mdx(\"p\",null,\"class AssignIssueHandler:\"),mdx(\"pre\",null,mdx(\"code\",t({parentName:\"pre\"},{}),`def __init__(self,\n           uowm: UnitOfWorkManager,\n           email_builder: EmailBuilder,\n           email_sender: EmailSender):\n    self.uowm = uowm\n    self.email_builder = email_builder\n    self.email_sender = email_sender\n\ndef handle(self, cmd):\n    # Assign Issue\n    with self.uowm.start() as uow:\n        issue = uow.issues.get(cmd.issue_id)\n        issue.assign_to(\n            cmd.assigned_to,\n            assigned_by=cmd.assigned_by\n        )\n        uow.commit()\n\n    # Send Email\n    email = self.email_builder.build(\n            cmd.assigned_to,\n            cmd.assigned_by,\n            issue.problem_description)\n    self.email_sender.send(email)\n`)),mdx(\"p\",null,`Something here feels wrong, right? Our command-handler now has two very distinct\nresponsibilities. Back at the beginning of this series we said we would stick with three\nprinciples:`),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},\"We will always define where our use-cases begin and end.\"),mdx(\"li\",{parentName:\"ol\"},\"We will depend on abstractions, and not on concrete implementations.\"),mdx(\"li\",{parentName:\"ol\"},`We will treat glue code as distinct from business logic, and put it in an\nappropriate place.`)),mdx(\"p\",null,`The latter two are being maintained here, but the first principle feels a little more\nstrained. At the very least we're violating the Single Responsibility Principle\n`,\"[https://en.wikipedia.org/wiki/Single_responsibility_principle]\",`; my rule of thumb for\nthe SRP is \"describe the behaviour of your class. If you use the word 'and' or 'then'\nyou may be breaking the SRP\". What does this class do? It assigns an issue to an\nengineer, AND THEN sends them an email. That's enough to get my refactoring senses\ntingling, but there's another, less theoretical, reason to split this method up, and\nit's to do with error handling.`),mdx(\"p\",null,`If I click a button marked \"Assign to engineer\", and I can't assign the issue to that\nengineer, then I expect an error. The system can't execute the command I've given to it,\nso I should retry, or choose a different engineer.`),mdx(\"p\",null,`If I click a button marked \"Assign to engineer\", and the system succeeds, but then can't\nsend a notification email, do I care? What action should I take in response? Should I\nassign the issue again? Should I assign it to someone else? What state will the system\nbe in if I do?`),mdx(\"p\",null,`Looking at the problem in this way, it's clear that \"assigning the issue\" is the real\nboundary of our use case, and we should either do that successfully, or fail completely.\n\"Send the email\" is a secondary side effect. If that part fails I don't want to see an\nerror - let the sysadmins clear it up later.`),mdx(\"p\",null,\"What if we split out the notification to another class?\"),mdx(\"p\",null,\"class AssignIssueHandler:\"),mdx(\"pre\",null,mdx(\"code\",t({parentName:\"pre\"},{}),`def __init__(self, uowm: UnitOfWorkManager):\n    self.uowm = uowm\n\ndef handle(self, cmd):\n    with self.uowm.start() as uow:\n        issue = uow.issues.get(cmd.issue_id)\n        issue.assign_to(\n            cmd.assignee_address,\n            assigned_by=cmd.assigner_address\n        )\n        uow.commit()\n`)),mdx(\"p\",null,\"class SendAssignmentEmailHandler def \",mdx(\"strong\",{parentName:\"p\"},\"init\"),`(self, uowm: UnitOfWorkManager,\nemail_builder: EmailBuilder, email_sender: EmailSender): self.uowm = uowm\nself.email_builder = email_builder self.email_sender = email_sender`),mdx(\"pre\",null,mdx(\"code\",t({parentName:\"pre\"},{}),`def handle(self, cmd):\n    with self.uowm.start() as uow:\n        issue = uow.issues.get(cmd.issue_id)\n\n        email = self.email_builder.build(\n            cmd.assignee_address,\n            cmd.assigner_address,\n            issue.problem_description)\n        self.email_sender.send(email)\n`)),mdx(\"p\",null,`We don't really need a unit of work here, because we're not making any persistent\nchanges to the Issue state, so what if we use a view builder instead?`),mdx(\"p\",null,\"class SendAssignmentEmailHandler def \",mdx(\"strong\",{parentName:\"p\"},\"init\"),`(self, view: IssueViewBuilder,\nemail_builder: EmailBuilder, email_sender: EmailSender): self.view = view\nself.email_builder = email_builder self.email_sender = email_sender`),mdx(\"pre\",null,mdx(\"code\",t({parentName:\"pre\"},{}),`def handle(self, cmd):\n    issue = self.view.fetch(cmd.issue_id)\n\n    email = self.email_builder.build(\n        cmd.assignee_address,\n        cmd.assigner_address,\n        issue['problem_description'])\n    self.email_sender.send(email)\n`)),mdx(\"p\",null,`That seems better, but how should we invoke our new handler? Building a new command and\nhandler from inside our AssignIssueHandler also sounds like a violation of SRP. Worse\nstill, if we start calling handlers from handlers, we'll end up with our use cases\ncoupled together again - and that's definitely a violation of Principle #1.`),mdx(\"p\",null,`What we need is a way to signal between handlers - a way of saying \"I did my job, can\nyou go do yours?\"`),mdx(\"p\",null,`All Aboard the Message Bus In this kind of system, we use Domain Events\n`,\"[http://verraes.net/2014/11/domain-events/]\",` to fill that need. Events are closely\nrelated to Commands, in that both commands and events are types of message\n`,\"[http://www.enterpriseintegrationpatterns.com/patterns/messaging/Message.html]\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},`named chunks of data sent between entities. Commands and events differ only in their\nintent:`)),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},`Commands are named with the imperative tense (Do this thing), events are named in\nthe past tense (Thing was done).`),mdx(\"li\",{parentName:\"ol\"},`Commands must be handled by exactly one handler, events can be handled by 0 to N\nhandlers.`),mdx(\"li\",{parentName:\"ol\"},`If an error occurs when processing a command, the entire request should fail. If an\nerror occurs while processing an event, we should fail gracefully.`)),mdx(\"p\",null,`We will often use domain events to signal that a command has been processed and to do\nany additional book-keeping. When should we use a domain event? Going back to our\nprinciple #1, we should use events to trigger workflows that fall outside of our\nimmediate use-case boundary. In this instance, our use-case boundary is \"assign the\nissue\", and there is a second requirement \"notify the assignee\" that should happen as a\nsecondary result. Notifications, to humans or other systems, are one of the most common\nreasons to trigger events in this way, but they might also be used to clear a cache, or\nregenerate a view model, or execute some logic to make the system eventually consistent.`),mdx(\"p\",null,`Armed with this knowledge, we know what to do - we need to raise a domain event when we\nassign an issue to an engineer. We don't want to know about the subscribers to our\nevent, though, or we'll remain coupled; what we need is a mediator, a piece of\ninfrastructure that can route messages to the correct places. What we need is a message\nbus. A message bus is a simple piece of middleware that's responsible for getting\nmessages to the right listeners. In our application we have two kinds of message,\ncommands and events. These two types of message are in some sense symmetrical, so we'll\nuse a single message bus for both.`),mdx(\"p\",null,`How do we start off writing a message bus? Well, it needs to look up subscribers based\non the name of an event. That sounds like a dict to me:`),mdx(\"p\",null,\"class MessageBus:\"),mdx(\"pre\",null,mdx(\"code\",t({parentName:\"pre\"},{}),`def __init__(self):\n    \"\"\"Our message bus is just a mapping from message type\n       to a list of handlers\"\"\"\n    self.subscribers = defaultdict(list)\n\ndef handle(self, msg):\n    \"\"\"The handle method invokes each handler in turn\n       with our event\"\"\"\n    msg_name = type(msg).__name__\n    subscribers = self.subscribers[msg_name]\n    for subscriber in subscribers:\n        subscriber.handle(cmd)\n\ndef subscribe_to(self, msg, handler):\n    \"\"\"Subscribe sets up a new mapping, we make sure not\n       to allow more than one handler for a command\"\"\"\n    subscribers = [msg.__name__]\n    if msg.is_cmd and len(subscribers) \u003e 0:\n       raise CommandAlreadySubscribedException(msg.__name__)\n    subscribers.append(handler)\n`)),mdx(\"h1\",null,\"Example usage\"),mdx(\"p\",null,`bus = MessageBus() bus.subscribe_to(ReportIssueCommand,\nReportIssueHandler(db.unit_of_work_manager)) bus.handle(cmd)`),mdx(\"p\",null,`Here we have a bare-bones implementation of a message bus. It doesn't do anything fancy,\nbut it will do the job for now. In a production system, the message bus is an excellent\nplace to put cross-cutting concerns; for example, we might want to validate our commands\nbefore passing them to handlers, or we may want to perform some basic logging, or\nperformance monitoring. I want to talk more about that in the next part, when we'll\ntackle the controversial subject of dependency injection and Inversion of Control\ncontainers.`),mdx(\"p\",null,`For now, let's look at how to hook this up. Firstly, we want to use it from our API\nhandlers.`),mdx(\"p\",null,\"@api.route('/issues', methods=\",\"['POST']\",`) def create_issue(self): issue_id = uuid.uuid4()\ncmd = ReportIssueCommand(issue_id=issue_id, `,\"*\",\"*\",`request.get_json()) bus.handle(cmd)\nreturn \"\", 201, {\"Location\": \"/issues/\" + str(issue_id) }`),mdx(\"p\",null,`Not much has changed here - we're still building our command in the Flask adapter, but\nnow we're passing it into a bus instead of directly constructing a handler for\nourselves. What about when we need to raise an event? We've got several options for\ndoing this. Usually I raise events from my command handlers, like this:`),mdx(\"p\",null,\"class AssignIssueHandler:\"),mdx(\"pre\",null,mdx(\"code\",t({parentName:\"pre\"},{}),`def handle(self, cmd):\n    with self.uowm.start() as uow:\n        issue = uow.issues.get(cmd.id)\n        issue.assign_to(cmd.assigned_to, cmd.assigned_by)\n        uow.commit()\n\n    # This is step 4: notify other parts of the system\n    self.bus.raise(IssueAssignedToEngineer(\n        cmd.issue_id,\n        cmd.assigned_to,\n        cmd.assigned_by))\n`)),mdx(\"p\",null,`I usually think of this event-raising as a kind of glue - it's orchestration code.\nRaising events from your handlers this way makes the flow of messages explicit - you\ndon't have to look anywhere else in the system to understand which events will flow from\na command. It's also very simple in terms of plumbing. The counter argument is that this\nfeels like we're violating SRP in exactly the same way as before - we're sending a\nnotification about our workflow. Is this really any different to sending the email\ndirectly from the handler? Another option is to send events directly from our model\nobjects, and treat them as part our domain model proper.`),mdx(\"p\",null,\"class Issue:\"),mdx(\"pre\",null,mdx(\"code\",t({parentName:\"pre\"},{}),`def assign_to(self, assigned_to, assigned_by):\n    self.assigned_to = assigned_to\n    self.assigned_by = assigned_by\n\n    # Add our new event to a list\n    self.events.add(IssueAssignedToEngineer(self.id, self.assigned_to, self.assigned_by))\n`)),mdx(\"p\",null,`There's a couple of benefits of doing this: firstly, it keeps our command handler\nsimpler, but secondly it pushes the logic for deciding when to send an event into the\nmodel. For example, maybe we don't always need to raise the event.`),mdx(\"p\",null,\"class Issue:\"),mdx(\"pre\",null,mdx(\"code\",t({parentName:\"pre\"},{}),`def assign_to(self, assigned_to, assigned_by):\n    self.assigned_to = assigned_to\n    self.assigned_by = assigned_by\n\n    # don't raise the event if I picked the issue myself\n    if self.assigned_to != self.assigned_by:\n        self.events.add(IssueAssignedToEngineer(self.id, self.assigned_to, self.assigned_by))\n`)),mdx(\"p\",null,`Now we'll only raise our event if the issue was assigned by another engineer. Cases like\nthis are more like business logic than glue code, so today I'm choosing to put them in\nmy domain model. Updating our unit tests is trivial, because we're just exposing the\nevents as a list on our model objects:`),mdx(\"p\",null,\"class When_assigning_an_issue:\"),mdx(\"pre\",null,mdx(\"code\",t({parentName:\"pre\"},{}),`issue_id = uuid.uuid4()\nassigned_to = 'ashley@example.org'\nassigned_by = 'laura@example.org'\n\ndef given_a_new_issue(self):\n    self.issue = Issue(self.issue_id, 'reporter@example.org', 'how do I even?')\n\ndef because_we_assign_the_issue(self):\n    self.issue.assign(self.assigned_to, self.assigned_by)\n\ndef we_should_raise_issue_assigned(self):\n    expect(self.issue).to(have_raised(\n        IssueAssignedToEngineer(self.issue_id,\n                                self.assigned_to,\n                                self.assigned_by)))\n`)),mdx(\"p\",null,`The have_raised function is a custom matcher I wrote that checks the events attribute of\nour object to see if we raised the correct event. It's easy to test for the presence of\nevents, because they're namedtuples, and have value equality.`),mdx(\"p\",null,`All that remains is to get the events off our model objects and into our message bus.\nWhat we need is a way to detect that we've finished one use-case and are ready to flush\nour changes. Fortunately, we have a name for this already - it's a unit of work. In this\nsystem I'm using SQLAlchemy's event hooks\n`,\"[http://docs.sqlalchemy.org/en/latest/orm/session_events.html]\",` to work out which objects\nhave changed, and queue up their events. When the unit of work exits, we raise the\nevents.`),mdx(\"p\",null,\"class SqlAlchemyUnitOfWork(UnitOfWork):\"),mdx(\"pre\",null,mdx(\"code\",t({parentName:\"pre\"},{}),`def __init__(self, sessionfactory, bus):\n    self.sessionfactory = sessionfactory\n    self.bus = bus\n    # We want to listen to flush events so that we can get events\n    # from our model objects\n    event.listen(self.sessionfactory, \"after_flush\", self.gather_events)\n\ndef __enter__(self):\n    self.session = self.sessionfactory()\n    # When we first start a unit of work, create a list of events\n    self.flushed_events = []\n    return self\n\ndef commit(self):\n    self.session.flush()\n    self.session.commit()\n\ndef rollback(self):\n    self.session.rollback()\n    # If we roll back our changes we should drop all the events\n    self.events = []\n\ndef gather_events(self, session, ctx):\n    # When we flush changes, add all the events from our new and\n    # updated entities into the events list\n    flushed_objects = ([e for e in session.new]\n                    + [e for e in session.dirty])\n    for e in flushed_objects:\n        self.flushed_events += e.events\n\ndef publish_events(self):\n    # When the unit of work completes\n    # raise any events that are in the list\n    for e in self.flushed_events:\n        self.bus.handle(e)\n\ndef __exit__(self, type, value, traceback):\n    self.session.close()\n    self.publish_events()\n`)),mdx(\"p\",null,`Okay, we've covered a lot of ground here. We've discussed why you might want to use\ndomain events, how a message bus actually works in practice, and how we can get events\nout of our domain and into our subscribers. The newest code sample\n`,\"[https://github.com/bobthemighty/blog-code-samples/tree/master/ports-and-adapters/04]\",`\ndemonstrates these ideas, please do check it out, run it, open pull requests, open\nGithub issues etc.`),mdx(\"p\",null,`Some people get nervous about the design of the message bus, or the unit of work, but\nthis is just infrastructure - it can be ugly, so long as it works. We're unlikely to\never change this code after the first few user-stories. It's okay to have some crufty\ncode here, so long as it's in our glue layers, safely away from our domain model.\nRemember, we're doing all of this so that our domain model can stay pure and be flexible\nwhen we need to refactor. Not all layers of the system are equal, glue code is just\nglue.`),mdx(\"p\",null,`Next time I want to talk about Dependency Injection, why it's great, and why it's\nnothing to be afraid of.`))}MDXContent.isMDXComponent=!0;\n","scope":{}},"title":"Why use domain events","layout":"post","author":"Bob","categories":["ports \u0026 adapters"],"tags":["python","architecture"]},"__N_SSG":true},"page":"/[slug]","query":{"slug":"2017-09-19-why-use-domain-events"},"buildId":"Wh2OZ5RTgu9TtehCz94O1","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>