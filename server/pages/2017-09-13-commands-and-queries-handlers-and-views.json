{"pageProps":{"source":{"compiledSource":"var l=Object.defineProperty,p=Object.defineProperties;var m=Object.getOwnPropertyDescriptors;var n=Object.getOwnPropertySymbols;var i=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable;var h=(e,t,s)=>t in e?l(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s,a=(e,t)=>{for(var s in t||(t={}))i.call(t,s)&&h(e,s,t[s]);if(n)for(var s of n(t))r.call(t,s)&&h(e,s,t[s]);return e},d=(e,t)=>p(e,m(t));var u=(e,t)=>{var s={};for(var o in e)i.call(e,o)&&t.indexOf(o)<0&&(s[o]=e[o]);if(e!=null&&n)for(var o of n(e))t.indexOf(o)<0&&r.call(e,o)&&(s[o]=e[o]);return s};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(s){var o=s,{components:e}=o,t=u(o,[\"components\"]);return mdx(MDXLayout,d(a(a({},layoutProps),t),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,`In the first and second parts of this series I introduced the\n`,mdx(\"a\",a({parentName:\"p\"},{href:\"https://io.made.com/blog/introducing-command-handler/\"}),\"Command-Handler\"),` and\n`,mdx(\"a\",a({parentName:\"p\"},{href:\"https://io.made.com/blog/repository-and-unit-of-work-pattern-in-python/\"}),\"Unit of Work and Repository\"),`\npatterns. I was intending to write about Message Buses, and some more stuff about domain\nmodelling, but I need to quickly skim over this first.`),mdx(\"p\",null,`If you've just started reading the Message Buses piece, and you're here to learn about\nApplication-Controlled Identifiers, you'll find those at the end of post, after a bunch\nof stuff about ORMs, CQRS, and some casual trolling of junior programmers.`),mdx(\"p\",null,`What is CQS ? The\n`,mdx(\"a\",a({parentName:\"p\"},{href:\"https://martinfowler.com/bliki/CommandQuerySeparation.html\"}),\"Command Query Separation\"),`\nprinciple was first described by Bertrand Meyer in the late Eighties. Per\n`,mdx(\"a\",a({parentName:\"p\"},{href:\"https://en.wikipedia.org/wiki/Command%E2%80%93query_separation\"}),\"wikipedia\"),`, the\nprinciple states:`),mdx(\"p\",null,`every method should either be a command that performs an action, or a query that returns\ndata to the caller, but not both. In other words, \"Asking a question should not change\nthe answer\". More formally, methods should return a value only if they are referentially\ntransparent and hence possess no side effects.`),mdx(\"p\",null,`Referential transparency is an important concept from functional programming. Briefly, a\nfunction is referentially transparent if you could replace it with a static value.`),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-python\"}),`class LightSwitch:\n\n    def toggle_light(self):\n        self.light_is_on = not self.light_is_on\n        return self.light_is_on\n\n    @property\n    def is_on(self):\n        return self.light_is_on\n`)),mdx(\"p\",null,`In this class, the is_on method is referentially transparent - I can replace it with the\nvalue True or False without any loss of functionality, but the method toggle_light is\nside-effectual: replacing its calls with a static value would break the contracts of the\nsystem. To comply with the Command-Query separation principle, we should not return a\nvalue from our toggle_light method.`),mdx(\"p\",null,`In some languages we would say that the is_on method is \"pure\". The advantage of\nsplitting our functions into those that have side effects and those that are pure is\nthat the code becomes easier to reason about. Haskell loves pure functions, and uses\nthis reasonability to do strange things, like re-ordering your code for you at\ncompilation time to make it more efficient. For those of us who work in more prosaic\nlanguages, if commands and queries are clearly distinguished, then I can read through a\ncode base and understand all the ways in which state can change. This is a huge win for\ndebugging because there is nothing worse than troubleshooting a system when you can't\nwork out which code-paths are changing your data.`),mdx(\"p\",null,`How do we get data out of a Command-Handler architecture? When we're working in a\nCommand-Handler system we obviously use Commands and Handlers to perform state changes,\nbut what should we do when we want to get data back out of our model? What is the\nequivalent port for queries?`),mdx(\"p\",null,`The answer is \"it depends\". The lowest-cost option is just to re-use your repositories\nin your UI entrypoints.`),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-python\"}),`@app.route(\"/issues\")\ndef list_issues():\n    with unit_of_work_manager.start() as unit_of_work:\n        open_issues = unit_of_work.issues.find_by_status('open')\n        return json.dumps(open_issues)\n`)),mdx(\"p\",null,`This is totally fine unless you have complex formatting, or multiple entrypoints to your\nsystem. The problem with using your repositories directly in this way is that it's a\nslippery slope. Sooner or later you're going to have a tight deadline, and a simple\nrequirement, and the temptation is to skip all the command/handler nonsense and do it\ndirectly in the web api.`),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-python\"}),`@app.route('/issues/<issue_id>', methods=['DELETE'])\ndef delete_issue(issue_id):\n    with unit_of_work_manager.start() as uow:\n        issue = uow.issues[issue_id]\n        issue.delete()\n        uow.commit()\n`)),mdx(\"p\",null,`Super convenient, but then you need to add some error handling and some logging and an\nemail notification.`),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-python\"}),`@app.route('/issues/<issue_id>', methods=['DELETE'])\ndef delete_issue(issue_id):\n    logging.info(\"Handling DELETE of issue \"+str(issue_id))\n\n    with unit_of_work_manager.start() as uow:\n       issue = uow.issues[issue_id]\n\n       if issue is None:\n           logging.warn(\"Issue not found\")\n           flask.abort(404)\n       if issue.status != 'deleted':\n          issue.delete()\n          uow.commit()\n          try:\n             smtp.send_notification(Issue.Deleted, issue_id)\n          except:\n             logging.error(\n                \"Failed to send email notification for deleted issue \"\n                 + str(issue_id), exn_info=True)\n       else:\n          logging.info(\"Issue already deleted. NOOP\")\n    return \"Deleted!\", 202\n`)),mdx(\"p\",null,`Aaaaand, we're back to where we started: business logic mixed with glue code, and the\nwhole mess slowly congealing in our web controllers. Of course, the slippery slope\nargument isn't a good reason not to do something, so if your queries are very simple,\nand you can avoid the temptation to do updates from your controllers, then you might as\nwell go ahead and read from repositories, it's all good, you have my blessing. If you\nwant to avoid this, because your reads are complex, or because you're trying to stay\npure, then instead we could define our views explicitly.`),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-python\"}),`class OpenIssuesList:\n\n    def __init__(self, sessionmaker):\n        self.sessionmaker = sessionmaker\n\n    def fetch(self):\n        with self.sessionmaker() as session:\n            result = session.execute(\n                'SELECT reporter_name, timestamp, title\n                 FROM issues WHERE state=\"open\"')\n            return [dict(r) for r in result.fetchall()]\n\n@api.route('/issues/')\ndef list_issues():\n    view_builder = OpenIssuesList(session_maker)\n    return jsonify(view_builder.fetch())\n`)),mdx(\"p\",null,`This is my favourite part of teaching ports and adapters to junior programmers, because\nthe conversation inevitably goes like this:`),mdx(\"p\",null,`smooth-faced youngling: Wow, um... are you - are we just going to hardcode that sql in\nthere? Just ... run it on the database?`),mdx(\"p\",null,`grizzled old architect: Yeah, I think so. Do The Simplest Thing That Could Possibly\nWork, right? YOLO, and so forth.`),mdx(\"p\",null,`sfy: Oh, okay. Um... but what about the unit of work and the domain model and the\nservice layer and the hexagonal stuff? Didn't you say that \"Data access ought to be\nperformed against the aggregate root for the use case, so that we maintain tight control\nof transactional boundaries\"?`),mdx(\"p\",null,\"goa: Ehhhh... I don't feel like doing that right now, I think I'm getting hungry.\"),mdx(\"p\",null,\"sfy: Right, right ... but what if your database schema changes?\"),mdx(\"p\",null,`goa: I guess I'll just come back and change that one line of SQL. My acceptance tests\nwill fail if I forget, so I can't get the code through CI.`),mdx(\"p\",null,`sfy: But why don't we use the Issue model we wrote? It seems weird to just ignore it and\nreturn this dict... and you said \"Avoid taking a dependency directly on frameworks. Work\nagainst an abstraction so that if your dependency changes, that doesn't force change to\nripple through your domain\". You know we can't unit test this, right?`),mdx(\"p\",null,`goa: Ha! What are you, some kind of architecture astronaut? Domain models! Who needs\n'em.`),mdx(\"p\",null,`Why have a separate read-model? In my experience, there are two ways that teams go wrong\nwhen using ORMs. The most common mistake is not paying enough attention to the\nboundaries of their use cases. This leads to the application making far too many calls\nto the database because people write code like this:`),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-python\"}),`# Find all users who are assigned this task\n\n# [[and]] notify them and their line manager\n\n# then move the task to their in-queue\n\n\nnotification = task.as_notification()\nfor assignee in task.assignees:\n    assignee.manager.notifications.add(notification)\n    assignee.notifications.add(notification)\n    assignee.queues.inbox.add(task)\n`)),mdx(\"p\",null,`ORMs make it very easy to \"dot\" through the object model this way, and pretend that we\nhave our data in memory, but this quickly leads to performance issues when the ORM\ngenerates hundreds of select statements in response. Then they get all angry about\nperformance and write long blog posts about how ORM sucks and is an anti-pattern and\nonly n00bs like it. This is akin to blaming OO for your domain logic ending up in the\ncontroller.`),mdx(\"p\",null,`The second mistake that teams make is using an ORM when they don't need to. Why do we\nuse an ORM in the first place? I think that a good ORM gives us two things:`),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},\"A unit of work pattern which can be used to control our consistency boundaries.\"),mdx(\"li\",{parentName:\"ol\"},`A data mapper pattern that lets us map a complex object graph to relational tables,\nwithout writing tons of boring glue code.`)),mdx(\"p\",null,`Taken together, these patterns help us to write rich domain models by removing all the\ndatabase cruft so we can focus on our use-cases. This allows us to model complex\nbusiness processes in an internally consistent way. When I'm writing a GET method,\nthough, I don't care about any of that. My view doesn't need any business logic, because\nit doesn't change any state. For 99.5% of use cases, it doesn't even matter if my data\nare fetched inside a transaction. If I perform a dirty read when listing the issues, one\nof three things might happen:`),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},`I might see changes that aren't yet committed - maybe an Issue that has just been\ndeleted will still show up in the list.`),mdx(\"li\",{parentName:\"ol\"},`I might not see changes that have been committed - an Issue could be missing from\nthe list, or a title might be 10ms out of date.`),mdx(\"li\",{parentName:\"ol\"},\"I might see duplicates of my data - an Issue could appear twice in the list.\")),mdx(\"p\",null,`In many systems all these occurrences are unlikely, and will be resolved by a page\nrefresh or following a link to view more data. To be clear, I'm not recommending that\nyou turn off transactions for your SELECT statements, just noting that transactional\nconsistency is usually only a real requirement when we are changing state. When viewing\nstate, we can almost always accept a weaker consistency model.`),mdx(\"p\",null,`CQRS is CQS at a system-level CQRS stands for Command-Query Responsibility Segregation,\nand it's an architectural pattern that was popularised by Greg Young. A lot of people\nmisunderstand CQRS, and think you need to use separate databases and crazy asynchronous\nprocessors to make it work. You can do these things, and I want to write more about that\nlater, but CQRS just means that we separate the Write Model - what we normally think of\nas the domain model - and the Read Model - a lightweight, simple model for showing on\nthe UI, or answering questions about the domain state.`),mdx(\"p\",null,`When I'm serving a write request (a command), my job is to protect the invariants of the\nsystem, and model the business process as it appears in the minds of our domain experts.\nI take the collective understanding of our business analysts, and turn it into a state\nmachine that makes useful work happen. When I'm serving a read request (a query), my job\nis to get the data out of the database as fast as possible and onto a screen so the user\ncan view it. Anything that gets in the way of my doing that is bloat.`),mdx(\"p\",null,`This isn't a new idea, or particularly controversial. We've all tried writing reports\nagainst an ORM, or complex hierarchical listing pages, and hit performance barriers.\nWhen we get to that point, the only thing we can do - short of rewriting the whole\nmodel, or abandoning our use of an ORM - is to rewrite our queries in raw SQL. Once upon\na time I'd feel bad for doing this, as though I were cheating, but nowadays I just\nrecognise that the requirements for my queries are fundamentally different than the\nrequirements for my commands.`),mdx(\"p\",null,`For the write-side of the system, use an ORM, for the read side, use whatever is a)\nfast, and b) convenient.`),mdx(\"p\",null,\"Application Controlled Identifiers At this point, a non-junior programmer will say\"),mdx(\"p\",null,`Okay, Mr Smarty-pants Architect, if our commands can't return any values, and our domain\nmodels don't know anything about the database, then how do I get an ID back from my save\nmethod? Let's say I create an API for creating new issues, and when I have POSTed the\nnew issue, I want to redirect the user to an endpoint where they can GET their new\nIssue. How can I get the id back?`),mdx(\"p\",null,`The way I would recommend you handle this is simple - instead of letting your database\nchoose ids for you, just choose them yourself.`),mdx(\"pre\",null,mdx(\"code\",a({parentName:\"pre\"},{className:\"language-python\"}),`@api.route('/issues', methods=['POST'])\ndef report_issue(self): # uuids make great\n    domain-controlled identifiers, because # they can be shared amongst several systems and\n    are easy # to generate. issue_id = uuid.uuid4()\n\n    cmd = ReportIssueCommand(issue_id, **request.get_json())\n    handler.handle(cmd)\n    return \"\", 201, { 'Location': '/issues/' + str(issue_id) }\n`)),mdx(\"p\",null,`There's a few ways to do this, the most common is just to use a UUID, but you can also\nimplement something like `,mdx(\"a\",a({parentName:\"p\"},{href:\"https://pypi.python.org/pypi/sqlalchemy-hilo/0.1.2\"}),\"hi-lo\"),`. In\nthe\n`,mdx(\"a\",a({parentName:\"p\"},{href:\"https://github.com/bobthemighty/blog-code-samples/tree/master/ports-and-adapters/03\"}),\"new code sample\"),`,\nI've implemented three flask endpoints, one to create a new issue, one to list all\nissues, and one to view a single issue. I'm using UUIDs as my identifiers, but I'm still\nusing an integer primary key on the issues table, because using a GUID in a clustered\nindex leads to table fragmentation and sadness\n`,\"[http://sqlmag.com/database-performance-tuning/clustered-indexes-based-upon-guids]\",\" .\"),mdx(\"p\",null,`Okay, quick spot-check - how are we shaping up against our original Ports and Adapters\ndiagram? How do the concepts map?`),mdx(\"p\",null,`Pretty well! Our domain is pure and doesn't know anything about infrastructure or IO. We\nhave a command and a handler that orchestrate a use-case, and we can drive our\napplication from tests or Flask. Most importantly, the layers on the outside depend on\nthe layers toward the centre.`),mdx(\"p\",null,\"Next time I'll get back to talking about message buses.\"))}MDXContent.isMDXComponent=!0;\n","scope":{}},"date":"2017-09-13","title":"Commands and queries handlers and views","layout":"post","author":"Bob","categories":["ports & adapters"],"tags":["python","architecture"]},"__N_SSG":true}