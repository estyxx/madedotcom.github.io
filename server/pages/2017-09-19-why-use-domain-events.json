{"pageProps":{"source":{"compiledSource":"var h=Object.defineProperty,m=Object.defineProperties;var c=Object.getOwnPropertyDescriptors;var o=Object.getOwnPropertySymbols;var i=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable;var l=(s,t,a)=>t in s?h(s,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):s[t]=a,e=(s,t)=>{for(var a in t||(t={}))i.call(t,a)&&l(s,a,t[a]);if(o)for(var a of o(t))r.call(t,a)&&l(s,a,t[a]);return s},d=(s,t)=>m(s,c(t));var u=(s,t)=>{var a={};for(var n in s)i.call(s,n)&&t.indexOf(n)<0&&(a[n]=s[n]);if(s!=null&&o)for(var n of o(s))t.indexOf(n)<0&&r.call(s,n)&&(a[n]=s[n]);return a};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(a){var n=a,{components:s}=n,t=u(n,[\"components\"]);return mdx(MDXLayout,d(e(e({},layoutProps),t),{components:s,mdxType:\"MDXLayout\"}),mdx(\"p\",null,`Nota bene: this instalment in the Ports and Adapters with Command Handlers series is\ncode-heavy, and isn't going to make much sense unless you've read the previous parts:`),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},mdx(\"a\",e({parentName:\"li\"},{href:\"https://io.made.com/blog/introducing-command-handler/\"}),\"Introducing Command Handler\")),mdx(\"li\",{parentName:\"ul\"},mdx(\"a\",e({parentName:\"li\"},{href:\"https://io.made.com/blog/repository-and-unit-of-work-pattern-in-python/\"}),\"Repositories and Units of Work\")),mdx(\"li\",{parentName:\"ul\"},mdx(\"a\",e({parentName:\"li\"},{href:\"https://io.made.com/blog/commands-and-queries-handlers-and-views/\"}),\"Commands and Queries, Handlers and Views\"))),mdx(\"p\",null,`Okay, so we have a basic skeleton for an application and we can add new issues into the\ndatabase, then fetch them from a Flask API. So far, though, we don't have any domain\nlogic at all. All we have is a whole bunch of complicated crap where we could just have\na tiny Django app. Let's work through some more use-cases and start to flesh things out.`),mdx(\"p\",null,\"Back to our domain expert:\"),mdx(\"p\",null,\"So when we've added a reported issue to the issue log, what happens next?\"),mdx(\"p\",null,`Well we need to triage the problem and decide how urgent it is. Then we might assign it\nto a particular engineer, or we might leave it on the queue to be picked up by anyone.`),mdx(\"p\",null,`Wait, the queue? I thought you had an issue log, are they the same thing, or is there a\ndifference?`),mdx(\"p\",null,`Oh, yes. The issue log is just a record of all the issues we have received, but we work\nfrom the queue.`),mdx(\"p\",null,\"I see, and how do things get into the queue?\"),mdx(\"p\",null,`We triage the new items in the issue log to decide how urgent they are, and what\ncategories they should be in. When we know how to categorise them, and how urgent they\nare, we treat the issues as a queue, and work through them in priority order.`),mdx(\"p\",null,'This is because users always set things to \"Extremely urgent\"?'),mdx(\"p\",null,\"Yeah, it's just easier for us to triage the issues ourselves.\"),mdx(\"p\",null,`And what does that actually mean, like, do you just read the ticket and say \"oh, this is\n5 important, and it's in the broken mouse category\"?`),mdx(\"p\",null,`Mmmm... more or less, sometimes we need to ask more questions from the user so we'll\nemail them, or call them. Most things are first-come, first-served, but occasionally\nsomeone needs a fix before they can go to a meeting or something.`),mdx(\"p\",null,`So you email the user to get more information, or you call them up, and then you use\nthat information to assess the priority of the issue - sorry triage the issue, and work\nout what category it should go in... what do the categories achieve? Why categorise?`),mdx(\"p\",null,`Partly for reporting, so we can see what stuff is taking up the most time, or if there\nare clusters of similar problems on a particular batch of laptops for example. Mostly\nbecause different engineers have different skills, like if you have a problem with the\nActive Directory domain, then you should send that to Barry, or if it's an Exchange\nproblem, then George can sort it out, and Mike has the equipment log so he can give you\na temporary laptop and so on, and so on.`),mdx(\"p\",null,'Okay, and where do I find this \"queue\"?'),mdx(\"p\",null,`Your customer grins and gestures at the wall where a large whiteboard is covered in\npost-its and stickers of different colours.`),mdx(\"p\",null,`Mapping our requirements to our domain How can we map these requirements back to our\nsystem? Looking back over our notes with the domain expert, there's a few obvious verbs\nthat we should use to model our use cases. We can triage an issue, which means we\nprioritise and categorise it; we can assign a triaged issue to an engineer, or an\nengineer can pick up an unassigned issue. There's also a whole piece about asking\nquestions, which we might do synchronously by making a phone call and filling out some\nmore details, or asynchronously by sending an email. The Queue, with all of its stickers\nand sigils and swimlanes looks too complicated to handle today, so we'll dig deeper into\nthat separately.`),mdx(\"p\",null,`Let's quickly flesh out the triage use cases. We'll start by updating the existing unit\ntest for reporting an issue:`),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-python\"}),`class When_reporting_an_issue:\n\n    def given_an_empty_unit_of_work(self):\n        self.uow = FakeUnitOfWork()\n\n    def because_we_report_a_new_issue(self):\n        handler = ReportIssueHandler(self.uow)\n        cmd = ReportIssueCommand(id, name, email, desc)\n        handler.handle(cmd)\n\n    @property\n    def issue(self):\n        return self.uow.issues[0]\n\n    def it_should_be_awaiting_triage(self):\n        expect(self.issue.state).to(equal(IssueState.AwaitingTriage))\n`)),mdx(\"p\",null,`We're introducing a new concept - Issues now have a state, and a newly reported issue\nbegins in the AwaitingTriage state. We can quickly add a command and handler that allows\nus to triage an issue.`),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-python\"}),`class TriageIssueHandler:\n\n    def __init__(self, uowm: UnitOfWorkManager):\n        self.uowm = uowm\n\n    def handle(self, cmd):\n        with self.uowm.start() as uow:\n            issue = uow.issues.get(cmd.issue_id)\n            issue.triage(cmd.priority, cmd.category)\n            uow.commit()\n`)),mdx(\"p\",null,`Triaging an issue, for now, is a matter of selecting a category and priority. We'll use\na free string for category, and an enumeration for Priority. Once an issue is triaged,\nit enters the AwaitingAssignment state. At some point we'll need to add some view\nbuilders to list issues that are waiting for triage or assignment, but for now let's\nquickly add a handler so that an engineer can Pick an issue from the queue.`),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-python\"}),`class PickIssueHandler:\n\n    def __init__(self, uowm: UnitOfWorkManager):\n        self.uowm = uowm\n\n    def handle(self, cmd):\n        with self.uowm.start() as uow:\n            issue = uow.issues.get(cmd.issue_id)\n            issue.assign_to(cmd.picked_by)\n            uow.commit()\n`)),mdx(\"p\",null,`At this point, the handlers are becoming a little boring. As I said way back\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://io.made.com/blog/introducing-command-handler/\"}),\"in the first part\"),`, commands\nhandlers are supposed to be boring glue-code, and every command handler has the same\nbasic structure:`),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},\"Fetch current state.\"),mdx(\"li\",{parentName:\"ol\"},\"Mutate the state by calling a method on our domain model.\"),mdx(\"li\",{parentName:\"ol\"},\"Persist the new state.\"),mdx(\"li\",{parentName:\"ol\"},\"Notify other parts of the system that our state has changed.\")),mdx(\"p\",null,\"So far, though, we've only seen steps 1, 2, and 3. Let's introduce a new requirement.\"),mdx(\"p\",null,\"When an issue is assigned to an engineer, can we send them an email to let them know?\"),mdx(\"p\",null,`A brief discourse on SRP Let's try and implement this new requirement. Here's a first\nattempt:`),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-python\"}),`class AssignIssueHandler:\n\n    def __init__(self,\n               uowm: UnitOfWorkManager,\n               email_builder: EmailBuilder,\n               email_sender: EmailSender):\n        self.uowm = uowm\n        self.email_builder = email_builder\n        self.email_sender = email_sender\n\n    def handle(self, cmd):\n        # Assign Issue\n        with self.uowm.start() as uow:\n            issue = uow.issues.get(cmd.issue_id)\n            issue.assign_to(\n                cmd.assigned_to,\n                assigned_by=cmd.assigned_by\n            )\n            uow.commit()\n\n        # Send Email\n        email = self.email_builder.build(\n                cmd.assigned_to,\n                cmd.assigned_by,\n                issue.problem_description)\n        self.email_sender.send(email)\n`)),mdx(\"p\",null,`Something here feels wrong, right? Our command-handler now has two very distinct\nresponsibilities. Back at the beginning of this series we said we would stick with three\nprinciples:`),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},\"We will always define where our use-cases begin and end.\"),mdx(\"li\",{parentName:\"ol\"},\"We will depend on abstractions, and not on concrete implementations.\"),mdx(\"li\",{parentName:\"ol\"},`We will treat glue code as distinct from business logic, and put it in an\nappropriate place.`)),mdx(\"p\",null,`The latter two are being maintained here, but the first principle feels a little more\nstrained. At the very least we're violating the Single Responsibility Principle\n`,\"[https://en.wikipedia.org/wiki/Single_responsibility_principle]\",`; my rule of thumb for\nthe SRP is \"describe the behaviour of your class. If you use the word 'and' or 'then'\nyou may be breaking the SRP\". What does this class do? It assigns an issue to an\nengineer, AND THEN sends them an email. That's enough to get my refactoring senses\ntingling, but there's another, less theoretical, reason to split this method up, and\nit's to do with error handling.`),mdx(\"p\",null,`If I click a button marked \"Assign to engineer\", and I can't assign the issue to that\nengineer, then I expect an error. The system can't execute the command I've given to it,\nso I should retry, or choose a different engineer.`),mdx(\"p\",null,`If I click a button marked \"Assign to engineer\", and the system succeeds, but then can't\nsend a notification email, do I care? What action should I take in response? Should I\nassign the issue again? Should I assign it to someone else? What state will the system\nbe in if I do?`),mdx(\"p\",null,`Looking at the problem in this way, it's clear that \"assigning the issue\" is the real\nboundary of our use case, and we should either do that successfully, or fail completely.\n\"Send the email\" is a secondary side effect. If that part fails I don't want to see an\nerror - let the sysadmins clear it up later.`),mdx(\"p\",null,\"What if we split out the notification to another class?\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-python\"}),`class AssignIssueHandler:\n\n    def __init__(self, uowm: UnitOfWorkManager):\n        self.uowm = uowm\n\n    def handle(self, cmd):\n        with self.uowm.start() as uow:\n            issue = uow.issues.get(cmd.issue_id)\n            issue.assign_to(\n                cmd.assignee_address,\n                assigned_by=cmd.assigner_address\n            )\n            uow.commit()\n\nclass SendAssignmentEmailHandler:\n    def __init__(self,\n        uowm: UnitOfWorkManager,\n        email_builder: EmailBuilder,\n        email_sender: EmailSender\n    ):\n        self.uowm = uowm\n        self.email_builder = email_builder\n        self.email_sender = email_sender\n\n    def handle(self, cmd):\n        with self.uowm.start() as uow:\n            issue = uow.issues.get(cmd.issue_id)\n\n            email = self.email_builder.build(\n                cmd.assignee_address,\n                cmd.assigner_address,\n                issue.problem_description\n            )\n            self.email_sender.send(email)\n`)),mdx(\"p\",null,`We don't really need a unit of work here, because we're not making any persistent\nchanges to the Issue state, so what if we use a view builder instead?`),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-python\"}),`class SendAssignmentEmailHandler:\n    def __init__(self,\n        view: IssueViewBuilder,\n        email_builder: EmailBuilder,\n        email_sender: EmailSender\n    ):\n        self.view = view\n        self.email_builder = email_builder\n        self.email_sender = email_sender\n\n    def handle(self, cmd):\n        issue = self.view.fetch(cmd.issue_id)\n\n        email = self.email_builder.build(\n            cmd.assignee_address,\n            cmd.assigner_address,\n            issue['problem_description']\n        )\n        self.email_sender.send(email)\n`)),mdx(\"p\",null,`That seems better, but how should we invoke our new handler? Building a new command and\nhandler from inside our AssignIssueHandler also sounds like a violation of SRP. Worse\nstill, if we start calling handlers from handlers, we'll end up with our use cases\ncoupled together again - and that's definitely a violation of Principle #1.`),mdx(\"p\",null,`What we need is a way to signal between handlers - a way of saying \"I did my job, can\nyou go do yours?\"`),mdx(\"p\",null,`All Aboard the Message Bus In this kind of system, we use\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"http://verraes.net/2014/11/domain-events/\"}),\"Domain Events\"),` to fill that need. Events are\nclosely related to Commands, in that both commands and events are\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"http://www.enterpriseintegrationpatterns.com/patterns/messaging/Message.html\"}),\"types of message\")),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},`named chunks of data sent between entities. Commands and events differ only in their\nintent:`)),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},`Commands are named with the imperative tense (Do this thing), events are named in\nthe past tense (Thing was done).`),mdx(\"li\",{parentName:\"ol\"},`Commands must be handled by exactly one handler, events can be handled by 0 to N\nhandlers.`),mdx(\"li\",{parentName:\"ol\"},`If an error occurs when processing a command, the entire request should fail. If an\nerror occurs while processing an event, we should fail gracefully.`)),mdx(\"p\",null,`We will often use domain events to signal that a command has been processed and to do\nany additional book-keeping. When should we use a domain event? Going back to our\nprinciple #1, we should use events to trigger workflows that fall outside of our\nimmediate use-case boundary. In this instance, our use-case boundary is \"assign the\nissue\", and there is a second requirement \"notify the assignee\" that should happen as a\nsecondary result. Notifications, to humans or other systems, are one of the most common\nreasons to trigger events in this way, but they might also be used to clear a cache, or\nregenerate a view model, or execute some logic to make the system eventually consistent.`),mdx(\"p\",null,`Armed with this knowledge, we know what to do - we need to raise a domain event when we\nassign an issue to an engineer. We don't want to know about the subscribers to our\nevent, though, or we'll remain coupled; what we need is a mediator, a piece of\ninfrastructure that can route messages to the correct places. What we need is a message\nbus. A message bus is a simple piece of middleware that's responsible for getting\nmessages to the right listeners. In our application we have two kinds of message,\ncommands and events. These two types of message are in some sense symmetrical, so we'll\nuse a single message bus for both.`),mdx(\"p\",null,`How do we start off writing a message bus? Well, it needs to look up subscribers based\non the name of an event. That sounds like a dict to me:`),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-python\"}),`class MessageBus:\n\n    def __init__(self):\n        \"\"\"Our message bus is just a mapping from message type\n           to a list of handlers\"\"\"\n        self.subscribers = defaultdict(list)\n\n    def handle(self, msg):\n        \"\"\"The handle method invokes each handler in turn\n           with our event\"\"\"\n        msg_name = type(msg).__name__\n        subscribers = self.subscribers[msg_name]\n        for subscriber in subscribers:\n            subscriber.handle(cmd)\n\n    def subscribe_to(self, msg, handler):\n        \"\"\"Subscribe sets up a new mapping, we make sure not\n           to allow more than one handler for a command\"\"\"\n        subscribers = [msg.__name__]\n        if msg.is_cmd and len(subscribers) > 0:\n           raise CommandAlreadySubscribedException(msg.__name__)\n        subscribers.append(handler)\n`)),mdx(\"h3\",null,\"Example usage\"),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-python\"}),`bus = MessageBus()\nbus.subscribe_to(ReportIssueCommand, ReportIssueHandler(db.unit_of_work_manager))\nbus.handle(cmd)\n`)),mdx(\"p\",null,`Here we have a bare-bones implementation of a message bus. It doesn't do anything fancy,\nbut it will do the job for now. In a production system, the message bus is an excellent\nplace to put cross-cutting concerns; for example, we might want to validate our commands\nbefore passing them to handlers, or we may want to perform some basic logging, or\nperformance monitoring. I want to talk more about that in the next part, when we'll\ntackle the controversial subject of dependency injection and Inversion of Control\ncontainers.`),mdx(\"p\",null,`For now, let's look at how to hook this up. Firstly, we want to use it from our API\nhandlers.`),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-python\"}),`@api.route('/issues', methods=['POST'])\ndef create_issue(self):\n    issue_id = uuid.uuid4()\n    cmd = ReportIssueCommand(issue_id=issue_id, **request.get_json())\n    bus.handle(cmd)\n    return \"\", 201, {\"Location\": \"/issues/\" + str(issue_id) }\n`)),mdx(\"p\",null,`Not much has changed here - we're still building our command in the Flask adapter, but\nnow we're passing it into a bus instead of directly constructing a handler for\nourselves. What about when we need to raise an event? We've got several options for\ndoing this. Usually I raise events from my command handlers, like this:`),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-python\"}),`class AssignIssueHandler:\n\n    def handle(self, cmd):\n        with self.uowm.start() as uow:\n            issue = uow.issues.get(cmd.id)\n            issue.assign_to(cmd.assigned_to, cmd.assigned_by)\n            uow.commit()\n\n        # This is step 4: notify other parts of the system\n        self.bus.raise(IssueAssignedToEngineer(\n            cmd.issue_id,\n            cmd.assigned_to,\n            cmd.assigned_by))\n`)),mdx(\"p\",null,`I usually think of this event-raising as a kind of glue - it's orchestration code.\nRaising events from your handlers this way makes the flow of messages explicit - you\ndon't have to look anywhere else in the system to understand which events will flow from\na command. It's also very simple in terms of plumbing. The counter argument is that this\nfeels like we're violating SRP in exactly the same way as before - we're sending a\nnotification about our workflow. Is this really any different to sending the email\ndirectly from the handler? Another option is to send events directly from our model\nobjects, and treat them as part our domain model proper.`),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-python\"}),`class Issue:\n    def assign_to(self, assigned_to, assigned_by):\n        self.assigned_to = assigned_to\n        self.assigned_by = assigned_by\n\n        # Add our new event to a list\n        self.events.add(IssueAssignedToEngineer(self.id, self.assigned_to, self.assigned_by))\n`)),mdx(\"p\",null,`There's a couple of benefits of doing this: firstly, it keeps our command handler\nsimpler, but secondly it pushes the logic for deciding when to send an event into the\nmodel. For example, maybe we don't always need to raise the event.`),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-python\"}),`class Issue:\n\n    def assign_to(self, assigned_to, assigned_by):\n        self.assigned_to = assigned_to\n        self.assigned_by = assigned_by\n\n        # don't raise the event if I picked the issue myself\n        if self.assigned_to != self.assigned_by:\n            self.events.add(IssueAssignedToEngineer(self.id, self.assigned_to, self.assigned_by))\n`)),mdx(\"p\",null,`Now we'll only raise our event if the issue was assigned by another engineer. Cases like\nthis are more like business logic than glue code, so today I'm choosing to put them in\nmy domain model. Updating our unit tests is trivial, because we're just exposing the\nevents as a list on our model objects:`),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-python\"}),`class When_assigning_an_issue:\n\n    issue_id = uuid.uuid4()\n    assigned_to = 'ashley@example.org'\n    assigned_by = 'laura@example.org'\n\n    def given_a_new_issue(self):\n        self.issue = Issue(self.issue_id, 'reporter@example.org', 'how do I even?')\n\n    def because_we_assign_the_issue(self):\n        self.issue.assign(self.assigned_to, self.assigned_by)\n\n    def we_should_raise_issue_assigned(self):\n        expect(self.issue).to(have_raised(\n            IssueAssignedToEngineer(self.issue_id,\n                                    self.assigned_to,\n                                    self.assigned_by)))\n`)),mdx(\"p\",null,`The have_raised function is a custom matcher I wrote that checks the events attribute of\nour object to see if we raised the correct event. It's easy to test for the presence of\nevents, because they're namedtuples, and have value equality.`),mdx(\"p\",null,`All that remains is to get the events off our model objects and into our message bus.\nWhat we need is a way to detect that we've finished one use-case and are ready to flush\nour changes. Fortunately, we have a name for this already - it's a unit of work. In this\nsystem I'm using\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"http://docs.sqlalchemy.org/en/latest/orm/session_events.html\"}),\"SQLAlchemy's event hooks\"),`\nto work out which objects have changed, and queue up their events. When the unit of work\nexits, we raise the events.`),mdx(\"pre\",null,mdx(\"code\",e({parentName:\"pre\"},{className:\"language-python\"}),`class SqlAlchemyUnitOfWork(UnitOfWork):\n\n    def __init__(self, sessionfactory, bus):\n        self.sessionfactory = sessionfactory\n        self.bus = bus\n        # We want to listen to flush events so that we can get events\n        # from our model objects\n        event.listen(self.sessionfactory, \"after_flush\", self.gather_events)\n\n    def __enter__(self):\n        self.session = self.sessionfactory()\n        # When we first start a unit of work, create a list of events\n        self.flushed_events = []\n        return self\n\n    def commit(self):\n        self.session.flush()\n        self.session.commit()\n\n    def rollback(self):\n        self.session.rollback()\n        # If we roll back our changes we should drop all the events\n        self.events = []\n\n    def gather_events(self, session, ctx):\n        # When we flush changes, add all the events from our new and\n        # updated entities into the events list\n        flushed_objects = ([e for e in session.new]\n                        + [e for e in session.dirty])\n        for e in flushed_objects:\n            self.flushed_events += e.events\n\n    def publish_events(self):\n        # When the unit of work completes\n        # raise any events that are in the list\n        for e in self.flushed_events:\n            self.bus.handle(e)\n\n    def __exit__(self, type, value, traceback):\n        self.session.close()\n        self.publish_events()\n`)),mdx(\"p\",null,`Okay, we've covered a lot of ground here. We've discussed why you might want to use\ndomain events, how a message bus actually works in practice, and how we can get events\nout of our domain and into our subscribers. The newest\n`,mdx(\"a\",e({parentName:\"p\"},{href:\"https://github.com/bobthemighty/blog-code-samples/tree/master/ports-and-adapters/04\"}),\"code sample\"),`\ndemonstrates these ideas, please do check it out, run it, open pull requests, open\nGithub issues etc.`),mdx(\"p\",null,`Some people get nervous about the design of the message bus, or the unit of work, but\nthis is just infrastructure - it can be ugly, so long as it works. We're unlikely to\never change this code after the first few user-stories. It's okay to have some crufty\ncode here, so long as it's in our glue layers, safely away from our domain model.\nRemember, we're doing all of this so that our domain model can stay pure and be flexible\nwhen we need to refactor. Not all layers of the system are equal, glue code is just\nglue.`),mdx(\"p\",null,`Next time I want to talk about Dependency Injection, why it's great, and why it's\nnothing to be afraid of.`))}MDXContent.isMDXComponent=!0;\n","scope":{}},"date":"2017-09-19","title":"Why use domain events","layout":"post","author":"Bob","categories":["ports & adapters"],"tags":["python","architecture"]},"__N_SSG":true}